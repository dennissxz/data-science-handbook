
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maximum Flow &#8212; Data Science Handbook</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Matching" href="32-matching.html" />
    <link rel="prev" title="Minimum Spanning Tree" href="21-minimum-spanning-tree.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      <h1 class="site-logo" id="site-title">Data Science Handbook</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../index.html">
   Data Science Handbook
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Foundations
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../11-math/00-math.html">
   Math
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/11-combinatorics.html">
     Combinatorics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/20-vector-spaces.html">
     Vector Spaces
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/31-geometry.html">
     Geometry
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/21-linear-algebra.html">
     Linear Algebra
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/51-linear-programming.html">
     Linear Programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/52-non-linear-programming.html">
     Non-linear Programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/test.html">
     Test
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/90-puzzles.html">
     Puzzles
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../12-probabilities/00-probabilities.html">
   Probabilities
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/11-expectation-and-variance.html">
     Expectation and Variance
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/13-correlation-and-dependence.html">
     Correlation and Dependence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/31-bayesian-theorem.html">
     Bayesian’s Theorem
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/51-markov-chain.html">
     Markov Chain
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/71-sampling.html">
     Sampling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/90-multivariate-notations.html">
     Multivariate Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/91-exponential-families.html">
     Exponential Families
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/91-large-sample-theory.html">
     Large Sample Theory
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../13-statistics/00-statistics.html">
   Statistics
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/11-sample-survey.html">
     Sample Survey
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/13-randomized-trial.html">
     Randomized Controlled Trials
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/21-hypothesis-testing.html">
     Hypothesis Testing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/23-common-tests.html">
     Common Tests
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/33-confusion-matrix.html">
     Confusion Matrix
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/41-maximum-likelihood-estimation.html">
     Maximum Likelihood Estimator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/43-estimators-evaluation.html">
     Estimators Evaluation
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../15-tools/00-tools.html">
   Tools
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../15-tools/11-python.html">
     Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../15-tools/21-r.html">
     R
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../15-tools/31-sql.html">
     SQL
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../15-tools/41-latex.html">
     LaTeX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../15-tools/51-myst.html">
     MyST Markdown
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Algorithms
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../20-algorithms-concepts/00-algorithms-concepts.html">
   Algorithms Concepts
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../20-algorithms-concepts/51-polynomial-reduction.html">
     Polynomial Reduction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../20-algorithms-concepts/53-P-and-NP.html">
     <span class="math notranslate nohighlight">
      \(P\)
     </span>
     and
     <span class="math notranslate nohighlight">
      \(NP\)
     </span>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../20-algorithms-concepts/61-randomized-algo.html">
     Randomized Algorithms
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../21-greedy-algorithms/00-greedy-algorithms.html">
   Greedy Algorithms
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../21-greedy-algorithms/11-interval-scheduling.html">
     Interval Scheduling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../21-greedy-algorithms/31-huffman-coding.html">
     Huffman Coding
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../23-dynamic-programming/00-dynamic-programming.html">
   Dynamic Programming
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/11-weighted-interval-scheduling.html">
     Weighted Interval Scheduling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/13-longest-common-subsequence.html">
     Longest Common Subsequence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/15-longest-increasing-subsequence.html">
     Longest Increasing Subsequence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/17-largest-sum-subsequence.html">
     Largest Sum Subsequence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/31-knapsack.html">
     Minimum Knapsack
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/51-chain-matrix-multiplication.html">
     Chain Matrix Multiplication
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="00-graph-related.html">
   Graph Related
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="13-shortest-path.html">
     Shortest Path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="21-minimum-spanning-tree.html">
     Minimum Spanning Tree
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Maximum Flow
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="32-matching.html">
     Matching
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="42-maximum-independent-set.html">
     Maximum Independent Set in Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="91-LP-max-flow-min-cut.html">
     LP on Max-flow and Min-cut
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../26-algo-for-big-data/00-algo-for-big-data.html">
   For Big Data
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../26-algo-for-big-data/10-streaming.html">
     Streaming Model
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Machine Learning
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../30-ml-basics/00-ml-basics.html">
   Machine Learning Basics
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/02-taxonomy.html">
     Taxonomy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/03-information-theory.html">
     Information Theory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/05-kernels.html">
     Kernels
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/11-data-issues.html">
     Data Issues
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/51-semi-supervised.html">
     Semi-supervised Learning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/53-self-supervised.html">
     Self-supervised Learning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/61-fourier-transform.html">
     Fourier Transform-based Representations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../31-regression/00-regression.html">
   Regression
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/11-lm-estimation.html">
     Linear Models - Estimation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/12-lm-inference.html">
     Linear Models - Inference
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/13-lm-diagnosis.html">
     Linear Models - Diagnosis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/14-lm-advanced.html">
     Linear Models - Advanced Topics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/21-generalized-linear-models.html">
     Generalized Linear Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/22-logistic-regression.html">
     Logistic Regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/23-multinomial-logitsitc.html">
     Multinomial Logistic Regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/24-ordinal-logistic.html">
     Ordinal Logistic Regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/25-poisson-regression.html">
     Poisson Regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/31-multivariate-regression.html">
     Multivariate Regression
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../32-classification/00-classification.html">
   Classification
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../32-classification/09-k-nearest-neighbors.html">
     K-nearest neighbors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../32-classification/11-support-vector-machine.html">
     Support Vector Machine
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../32-classification/21-decision-tree.html">
     Decision Tree
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../33-dimensionality-reduction/00-dimensionality-reduction.html">
   Dimensionality Reduction
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/11-principal-component-analysis.html">
     Principal Component Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/13-canonical-correlation-analysis.html">
     Canonical Correlation Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/21-multidimensional-scaling.html">
     Multidimensional Scaling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/23-graph-based-spectral-methods.html">
     Graph-based Spectral Methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/25-t-SNE.html">
     SNE and
     <span class="math notranslate nohighlight">
      \(t\)
     </span>
     -SNE
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/31-kernel-pca.html">
     Kernel PCA
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/32-kernel-cca.html">
     Kernel CCA
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/41-factor-analysis.html">
     Factor Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/51-correspondence-analysis.html">
     Correspondence Analysis
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../34-clustering/00-clustering.html">
   Clustering
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../34-clustering/11-k-means.html">
     <span class="math notranslate nohighlight">
      \(k\)
     </span>
     -means clustering
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../34-clustering/13-agglomerative-methods.html">
     Agglomerative Methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../34-clustering/31-spectral-clustering.html">
     Spectral Clustering
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../34-clustering/41-gaussian-mixtures.html">
     Gaussian Mixtures
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../35-graphical-models/00-graphical-models.html">
   Graphical Models
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
  <label for="toctree-checkbox-15">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../35-graphical-models/03-random-walks.html">
     Random Walks in Graphs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../35-graphical-models/11-hidden-markov-models.html">
     Hidden Markov Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../35-graphical-models/31-topic-models.html">
     Topic Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../35-graphical-models/33-language-models.html">
     Language Models
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../37-neural-networks/00-neural-networks.html">
   Neural Networks
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
  <label for="toctree-checkbox-16">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/01-stochastic-gradient-descent.html">
     Stochastic Gradient Descent
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/03-trainability.html">
     Trainability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/05-regularization.html">
     Regularization
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/11-autoencoders.html">
     Autoencoders
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/13-variational-autoencoders.html">
     Variational Autoencoders
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/31-sequential-models.html">
     Sequential Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/41-GAN.html">
     Generative Adversarial Networks
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../38-ml-for-graph-data/00-ml-for-graph-data.html">
   For Graph-structured Data
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/>
  <label for="toctree-checkbox-17">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../38-ml-for-graph-data/01-graph-basics.html">
     Graph Basics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../38-ml-for-graph-data/11-descriptive-analysis.html">
     Descriptive Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../38-ml-for-graph-data/13-sampling-and-estimation.html">
     Sampling and Estimation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../38-ml-for-graph-data/21-modeling.html">
     Modeling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../38-ml-for-graph-data/31-topology-inference.html">
     Topology Inference
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../38-ml-for-graph-data/41-processes.html">
     Processes on Graphs
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/25-graph-related/31-maximum-flow.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/dennissxz/data-science-handbook"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/dennissxz/data-science-handbook/issues/new?title=Issue%20on%20page%20%2F25-graph-related/31-maximum-flow.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#problem">
   Problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#analysis">
   Analysis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algorithm">
   Algorithm
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     Algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#feasibility">
     Feasibility
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optimality">
     Optimality
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complexity">
     Complexity
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#improvement-edmonds-karp-algorithm">
     Improvement: Edmonds-Karp Algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#approximation">
     Approximation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#other-properties">
     Other Properties
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#minimum-cut">
   Minimum Cut
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id2">
     Problem
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     Analysis
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#extension">
   Extension
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#max-flow-and-min-cut-in-undirected-graphs">
     Max-flow and Min-cut in Undirected Graphs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#minimum-cost-flow">
     Minimum Cost Flow
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#s-t-shortest-path">
     <span class="math notranslate nohighlight">
      \(s\)
     </span>
     -
     <span class="math notranslate nohighlight">
      \(t\)
     </span>
     Shortest Path
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#path-based-flow">
     Path-based Flow
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#edge-disjoint-paths">
     Edge-Disjoint Paths
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#s-t-cut">
     <span class="math notranslate nohighlight">
      \(S\)
     </span>
     -
     <span class="math notranslate nohighlight">
      \(T\)
     </span>
     Cut
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vertex-capacitated-max-flow">
     Vertex-capacitated Max Flow
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#applications">
   Applications
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#image-segmentation">
     Image Segmentation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercise">
   Exercise
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#more">
     More
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="maximum-flow">
<span id="max-flow"></span><h1>Maximum Flow<a class="headerlink" href="#maximum-flow" title="Permalink to this headline">¶</a></h1>
<p>Widely used in algorithms on graphs.</p>
<div class="section" id="problem">
<h2>Problem<a class="headerlink" href="#problem" title="Permalink to this headline">¶</a></h2>
<p>Send something from a place to another over some networks, e.g. information, package, oil.</p>
<p>Each edge has capacity limit.</p>
<dl class="simple myst">
<dt>Input</dt><dd><p>directed graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>, capacities <span class="math notranslate nohighlight">\(c(e)\ge 0\)</span>, source vertex <span class="math notranslate nohighlight">\(s\in V\)</span>, destination vertex <span class="math notranslate nohighlight">\(t \in V\)</span>.</p>
</dd>
<dt>Goal</dt><dd><p>find the maximum volume flowing from <span class="math notranslate nohighlight">\(s\)</span> to <span class="math notranslate nohighlight">\(t\)</span> subject to the capacity constraint.</p>
</dd>
</dl>
</div>
<div class="section" id="analysis">
<h2>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h2>
<p>Assume</p>
<ul class="simple">
<li><p>all capacities are integers (capacity is a finite number. if not integer, scale.)</p></li>
<li><p>no edges enter <span class="math notranslate nohighlight">\(s\)</span> or leave <span class="math notranslate nohighlight">\(t\)</span> (makes no sense to use those edges)</p></li>
<li><p>call all edges entering <span class="math notranslate nohighlight">\(v\)</span> by <span class="math notranslate nohighlight">\(\delta ^- (v)\)</span></p></li>
<li><p>call all edges leaving <span class="math notranslate nohighlight">\(v\)</span> by <span class="math notranslate nohighlight">\(\delta ^+ (v)\)</span></p></li>
</ul>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>If the two vertices of an edge are <span class="math notranslate nohighlight">\(e=(u,v)\)</span>, sometimes we write <span class="math notranslate nohighlight">\(f(u,v)\)</span> for convenience. If there is no edge between two vertices <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>, then <span class="math notranslate nohighlight">\(f(u,v)=0\)</span>.</p>
</div>
<dl class="simple myst">
<dt>Definition (Flow)</dt><dd><p>A function <span class="math notranslate nohighlight">\(f:E \rightarrow \mathbb{R}\)</span> which assign a value <span class="math notranslate nohighlight">\(f(e)\)</span> to every edge <span class="math notranslate nohighlight">\(e \in E\)</span>, subject to</p>
</dd>
</dl>
<ul>
<li><p>capacity constraints: edge flow less than edge capacity</p>
<div class="math notranslate nohighlight">
\[\forall e: \quad 0\le f(e) \le c(e)\]</div>
</li>
<li><p>flow conservation constraint: in-flow = out-flow for all intermediate nodes.</p>
<div class="math notranslate nohighlight">
\[\forall v \in V \backslash \left\{ s,t \right\}: \quad \sum_ {e\in \delta^- (v)} f(e) = \sum_ {e\in \delta^+ (v)} f(e) \quad\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[f^{\text{in}}(v) = f^{\text{out}}(v)\]</div>
</li>
</ul>
<dl class="simple myst">
<dt>Definition (Value of flow)</dt><dd><p>The value of a flow is the amount of out-flow from source node <span class="math notranslate nohighlight">\(s\)</span> (assuming no in-flow to <span class="math notranslate nohighlight">\(s\)</span>).</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{val}(f) = f^{\text{out}}(s) = \sum_ {e\in \delta^+ (s)} f(e)
  \]</div>
</dd>
<dt>Observation (Flow cancelation operation on anti-parallel edges)</dt><dd><p>For two anti-parallel edges <span class="math notranslate nohighlight">\(e = (u,v)\)</span> and <span class="math notranslate nohighlight">\(e ^\prime  = (v,u)\)</span>. Suppose <span class="math notranslate nohighlight">\(f(e), f(e ^\prime ) &gt;0\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\Delta = \min \left\{ f(e), f(e ^\prime ) \right\}\)</span> and assign new flow</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  f ^\prime (e) = f(e) - \Delta \\
  f ^\prime (e ^\prime ) = f(e ^\prime ) - \Delta
  \end{split}\]</div>
<p>Then the new flow <span class="math notranslate nohighlight">\(f ^\prime\)</span> is still a feasible flow with the same value of flow <span class="math notranslate nohighlight">\(f\)</span>.</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{val}(f ^\prime ) = \operatorname{val}(f)
  \]</div>
</dd>
</dl>
<div class="dropdown note admonition">
<p class="admonition-title"> Greedy algorithms not optimal</p>
<p>Given a simple <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> path <span class="math notranslate nohighlight">\(P\)</span> and a flow <span class="math notranslate nohighlight">\(f\)</span>, how much available capacity left?</p>
<div class="math notranslate nohighlight">
\[
\Delta(P) = \min _{e \in E(P)} \left\{ c(e) - f(e) \right\}
\]</div>
<ul class="simple">
<li><p>Start: <span class="math notranslate nohighlight">\(\forall e \in E, f(e) = 0\)</span></p></li>
<li><p>While there is a simple <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> path <span class="math notranslate nohighlight">\(P\)</span> with <span class="math notranslate nohighlight">\(\Delta(P)&gt;0\)</span>, set for every <span class="math notranslate nohighlight">\(e \in E(P)\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
f(e)\leftarrow f(e) + \Delta(p)
\]</div>
<p>This gives a feasible solution. Optimal? No, depends on the order of <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> path in <code class="docutils literal notranslate"><span class="pre">WHILE</span></code>.</p>
</div>
</div>
<div class="section" id="algorithm">
<h2>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Algorithm<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>We first make an additional assumption and define residual flow networks.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>This assumption is not necessary for the algorithm to run, but make the algorithm easier to understand.</p>
</div>
<dl class="simple myst">
<dt>Assumption (No anti-parallel edges)</dt><dd><p>Input <span class="math notranslate nohighlight">\(G\)</span> has no anti-parallel edges. If there is, say <span class="math notranslate nohighlight">\(e = (u,v)\)</span> and <span class="math notranslate nohighlight">\(e ^\prime  = (v,u)\)</span>, then add a node <span class="math notranslate nohighlight">\(x\)</span> in-between <span class="math notranslate nohighlight">\(e = (u,v)\)</span> and the new edges have the same capacity <span class="math notranslate nohighlight">\(c(u,x) = c(x,v) = c(u,v)\)</span>.</p>
</dd>
<dt>Definition (Residual Flow Network)</dt><dd><p>Given a graph <span class="math notranslate nohighlight">\(G\)</span> and a feasible flow <span class="math notranslate nohighlight">\(f\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, let <span class="math notranslate nohighlight">\(G_f\)</span> be a new graph with the same vertices but new edges.</p>
</dd>
</dl>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>One can check if the residual capacity assigned to a pair of forward edge and backward edge in the residual flow network are correct by checking their sum of residual capacity <span class="math notranslate nohighlight">\(c_f(e) + c_f(e ^\prime)\)</span>, which should be <span class="math notranslate nohighlight">\(c(e)\)</span>.</p>
</div>
<ul>
<li><p>For every <span class="math notranslate nohighlight">\(e(u,v) \in G\)</span>, add edges and assign capacity (called <strong>residual capacity</strong>)</p>
<ul>
<li><p>add a forward edge to reflect <strong>unused</strong> capacity of <span class="math notranslate nohighlight">\(e\)</span></p>
<div class="math notranslate nohighlight">
\[
        c_f (u,v) = c(e) - f(e)
        \]</div>
</li>
<li><p>add a backward edge <span class="math notranslate nohighlight">\((v,u)\)</span> to reflect <strong>used</strong> capacity</p>
<div class="math notranslate nohighlight">
\[
        c_f (v,u) = f(e)
        \]</div>
</li>
</ul>
</li>
<li><p>For every edge <span class="math notranslate nohighlight">\(e ^\prime\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span> with zero residual capacity <span class="math notranslate nohighlight">\(c_f (e ^\prime ) = 0\)</span>, delete.</p></li>
</ul>
<div class="figure align-default" id="max-flow-three-edges">
<a class="reference internal image-reference" href="../_images/max-flow-three-edges.png"><img alt="" src="../_images/max-flow-three-edges.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 27 </span><span class="caption-text">Three kinds of edge in <span class="math notranslate nohighlight">\(G\)</span> [Chuzhoy 2021]</span><a class="headerlink" href="#max-flow-three-edges" title="Permalink to this image">¶</a></p>
</div>
<p>Ford-Fulkerson algorithm is an iterative algorithm. In each iteration, we compute the residual floe network of the current graph and use that to improve the original graph. Note that flow <span class="math notranslate nohighlight">\(f()\)</span> only exists in the original graph.</p>
<hr class="docutils" />
<p><strong>Ford-Fulkerson’s algorithm</strong></p>
<hr class="docutils" />
<ul>
<li><p>Start:</p>
<ul>
<li><p>For all edge <span class="math notranslate nohighlight">\(e \in E(G)\)</span>, initialize zero flow <span class="math notranslate nohighlight">\(f(e)=0\)</span>.</p></li>
<li><p>Compute the residual flow network <span class="math notranslate nohighlight">\(G_f\)</span>. For every <span class="math notranslate nohighlight">\(e(u,v) \in G\)</span>, add edges and assign capacity (called <strong>residual capacity</strong>)</p>
<ul>
<li><p>add a forward edge to reflect <strong>unused</strong> capacity of <span class="math notranslate nohighlight">\(e\)</span></p>
<div class="math notranslate nohighlight">
\[
          c_f (u,v) = c(e) - f(e)
          \]</div>
</li>
<li><p>add a backward edge <span class="math notranslate nohighlight">\((v,u)\)</span> to reflect <strong>used</strong> capacity</p>
<div class="math notranslate nohighlight">
\[
          c_f (v,u) = f(e)
          \]</div>
</li>
<li><p>delete edges with zero residual capacity</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>An augmenting path in residual graph can be found using DFS or BFS.</p>
</div>
<ul>
<li><p>While <span class="math notranslate nohighlight">\(\exists\)</span> a simple path <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> path <span class="math notranslate nohighlight">\(P\)</span> in the residual flow network <span class="math notranslate nohighlight">\(G_f\)</span>, we “push” flow along this path (aka <em>augmenting path</em>).</p>
<ul>
<li><p>Compute the smallest residual capacity along that path</p>
<div class="math notranslate nohighlight">
\[\Delta \leftarrow \min _{e \in E(P)} \left\{ c_f(e) \right\}\]</div>
</li>
<li><p>For each edge <span class="math notranslate nohighlight">\(e=(u,v) \in P\)</span>, check whether it is a forward edge or a backward edge w.r.t. the original graph.</p>
<ul>
<li><p>If <span class="math notranslate nohighlight">\(e=(u,v)\)</span> is a forward edge, then <span class="math notranslate nohighlight">\((u,v) \in G\)</span>, and we <strong>increase</strong> the flow of that edge by <span class="math notranslate nohighlight">\(\Delta\)</span>,</p>
<div class="math notranslate nohighlight">
\[f(u,v)\leftarrow f(u,v) + \Delta\]</div>
</li>
<li><p>Else, <span class="math notranslate nohighlight">\(e=(u,v)\)</span> is a backward edge, then <span class="math notranslate nohighlight">\((v,u) \in G\)</span>, and we <strong>decrease</strong> the flow of <span class="math notranslate nohighlight">\((v,u)\)</span> by <span class="math notranslate nohighlight">\(\Delta\)</span>,</p>
<div class="math notranslate nohighlight">
\[f(v,u) \leftarrow f(v,u) - \Delta\]</div>
</li>
</ul>
</li>
<li><p>Re-compute <span class="math notranslate nohighlight">\(G_f\)</span>.</p></li>
</ul>
</li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="feasibility">
<h3>Feasibility<a class="headerlink" href="#feasibility" title="Permalink to this headline">¶</a></h3>
<dl class="simple myst">
<dt>Claim (Stops in finit time)</dt><dd><p>The FF algorithm stops after at most <span class="math notranslate nohighlight">\(\sum_{v\in \operatorname{succ}(s)} c(s, v)\)</span> iterations.</p>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof</em></p>
<p>Upon initialization, <span class="math notranslate nohighlight">\(f(e)=0\)</span> are integers. In each iteration, in <span class="math notranslate nohighlight">\(G_f\)</span>, all residual capacities <span class="math notranslate nohighlight">\(c_f(e)\)</span> are integers and at least 1. The smallest residual capacity is also integer and at least 1. So the update flow of each edge in <span class="math notranslate nohighlight">\(G\)</span> is <span class="math notranslate nohighlight">\(f(e)\leftarrow f(e) \pm \Delta\)</span>.</p>
<p>Note that along the augmenting path <span class="math notranslate nohighlight">\(P\)</span>, the first edge out from <span class="math notranslate nohighlight">\(s\)</span> is always a forward edge (by assumption). As a result, the updated flow of that edge is <span class="math notranslate nohighlight">\(f(e) \mathrel{+}= \Delta\)</span>. Hence, the updated value of the flow is <span class="math notranslate nohighlight">\(\operatorname{val}(f) \mathrel{+}= \Delta\)</span>, which is at least 1.</p>
<p>Therefore, the algorithm stops after at most <span class="math notranslate nohighlight">\(\sum_{v\in \operatorname{succ}(s)} c(s, v)\)</span> iterations.</p>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
<dl class="simple myst">
<dt>Claim 2 (Always a valid flow)</dt><dd><p>Flow <span class="math notranslate nohighlight">\(f\)</span> always remains a valid flow. That is, the flow always satisfies the capacity constraints and the conservation constraints.</p>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof by induction</em></p>
<ul class="simple">
<li><p>Base: <span class="math notranslate nohighlight">\(\forall e: f(e)=0\)</span> at initialization is a valid flow</p></li>
<li><p>Step: if at the beginning of an iteration, <span class="math notranslate nohighlight">\(f\)</span> is valid, then after the iteration, it remains valid.</p></li>
</ul>
<p>We now prove the capacity constraints and the conservation of flow constraints.</p>
<p><strong>Capacity constraints</strong></p>
<p>For every edge <span class="math notranslate nohighlight">\(e=(u,v)\)</span> in the augmenting path <span class="math notranslate nohighlight">\(P\)</span>,</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is a forward edge, <span class="math notranslate nohighlight">\(e \in G\)</span>, then we increases <span class="math notranslate nohighlight">\(f(e) \mathrel{+}= \Delta\)</span>. By definition, <span class="math notranslate nohighlight">\(\Delta \le c_f (e) =  c(e) - f(e)\)</span>. Hence <span class="math notranslate nohighlight">\(f(e)+\Delta \le c(e)\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is a backward edge, then <span class="math notranslate nohighlight">\(e ^\prime = (v,u)\in G\)</span>, we decrease <span class="math notranslate nohighlight">\(f(e ^\prime) \mathrel{-}= \Delta\)</span>. Will it be negative? No, since by definition, <span class="math notranslate nohighlight">\(\Delta \le c_f(e) = f(e ^\prime)\)</span>, so <span class="math notranslate nohighlight">\(f(e ^\prime) - \Delta \ge 0\)</span>.</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>Conservation of flow constraints</strong></p>
<p>By definition, we want to prove <span class="math notranslate nohighlight">\(\forall v \in V \backslash \left\{ s,t \right\}\)</span></p>
<div class="math notranslate nohighlight">
\[f^{\text{in}}(v) = f^{\text{out}}(v)\]</div>
<p>Suppose along <span class="math notranslate nohighlight">\(P\)</span> the two edges of <span class="math notranslate nohighlight">\(v\)</span> are <span class="math notranslate nohighlight">\(e_1, e_2\)</span></p>
<div class="math notranslate nohighlight">
\[ \text{along } P: \quad \ldots \overset{e_1}{\longrightarrow} v \overset{e_2}{\longrightarrow} \ldots\]</div>
<p>We have the following 3 possible situations for <span class="math notranslate nohighlight">\(e_1\)</span> and <span class="math notranslate nohighlight">\(e_2\)</span>,</p>
<ol>
<li><p>both forward edges, then we increase both <span class="math notranslate nohighlight">\(f(e_1)\)</span> and <span class="math notranslate nohighlight">\(f(e_2)\)</span> by <span class="math notranslate nohighlight">\(\Delta\)</span>, so the in- and out-flow of <span class="math notranslate nohighlight">\(v\)</span> both increases by <span class="math notranslate nohighlight">\(\Delta\)</span>.</p>
<div class="math notranslate nohighlight">
\[ \text{in } G: \quad \ldots \overset{e_1}{\longrightarrow} v \overset{e_2}{\longrightarrow} \ldots\]</div>
</li>
<li><p>both backward edges, then we decrease <span class="math notranslate nohighlight">\(f(e_1 ^\prime)\)</span> and <span class="math notranslate nohighlight">\(f(e_2 ^\prime)\)</span> by <span class="math notranslate nohighlight">\(\Delta\)</span>, so the in- and out-flow of <span class="math notranslate nohighlight">\(v\)</span> both decreases by <span class="math notranslate nohighlight">\(\Delta\)</span>.</p>
<div class="math notranslate nohighlight">
\[\text{in } G: \quad \ldots \overset{e_1 ^\prime }{\longleftarrow} v \overset{e_2 ^\prime }{\longleftarrow} \ldots\]</div>
</li>
<li><p><span class="math notranslate nohighlight">\(e_1\)</span> forward, <span class="math notranslate nohighlight">\(e_2\)</span> backward, then <span class="math notranslate nohighlight">\(f(e_1)\)</span> increases by <span class="math notranslate nohighlight">\(\Delta\)</span>, and <span class="math notranslate nohighlight">\(f(e_2 ^\prime)\)</span> decreases by <span class="math notranslate nohighlight">\(\Delta\)</span>, so the two changes to in-follow of <span class="math notranslate nohighlight">\(v\)</span> cancel out. No change to out-flow.</p>
<div class="math notranslate nohighlight">
\[\text{in } G: \quad \ldots \overset{e_1}{\longrightarrow} v \overset{e_2 ^\prime }{\longleftarrow} \ldots\]</div>
</li>
<li><p><span class="math notranslate nohighlight">\(e_2\)</span> forward, <span class="math notranslate nohighlight">\(e_1\)</span> backward, similar to the case 3.</p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
<p>Therefore, we show that after an iteration is completed, the constraints remain to be satisfied, so the feasibility is guaranteed.</p>
</div>
<div class="section" id="optimality">
<h3>Optimality<a class="headerlink" href="#optimality" title="Permalink to this headline">¶</a></h3>
<p>To prove optimality of the FF algorithm, we first introduce some definitions.</p>
<p>Recall the definition of in-flow to and out-flow from a node <span class="math notranslate nohighlight">\(v\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}
f^{\text{in}}(v) = \sum_{e \in \delta^{-}(v)} f(e) \\
f^{\text{out}}(v) =\sum_{e \in \delta^{+}(v)} f(e)
\end{split}\]</div>
<p>We define similar quantities for a set of vertices.</p>
<dl class="simple myst">
<dt>Definition (In- and out-flow of a set of vertices)</dt><dd><p>For a set of vertices <span class="math notranslate nohighlight">\(S \subseteq V\)</span>, ,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  f^{\text{in}}(S) &amp;= \sum_{u\notin S, v \in S} f(u, v) \\
  f^{\text{out}}(S) &amp;= \sum_{u\in S, v \notin S} f(u, v)
  \end{aligned}\end{split}\]</div>
</dd>
<dt>Definition (<span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut)</dt><dd><p>An <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span> is a cut in <span class="math notranslate nohighlight">\(G\)</span> such that the source node <span class="math notranslate nohighlight">\(s\in A\)</span> and the destination node <span class="math notranslate nohighlight">\(t\in B\)</span>. The in- and out-flow of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> have the relations</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  f^{\text{in}}(A) &amp;= f^{\text{out}}(B) \\
  f^{\text{out}}(A) &amp;= f^{\text{in}}(B)
  \end{aligned}\end{split}\]</div>
</dd>
<dt>Definition (Capacity of an <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut)</dt><dd><p>The capacity of an <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span> is defined as the sum of capacities of the edges from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span></p>
<div class="math notranslate nohighlight">
\[
  c(A,B) = \sum _{u\in A, v \in B} c(u, v)
  \]</div>
</dd>
<dt>Property (Compute flow value from a cut)</dt><dd><p>Let <span class="math notranslate nohighlight">\(f\)</span> be any flow in <span class="math notranslate nohighlight">\(G\)</span>, recall that the definition of flow value <span class="math notranslate nohighlight">\(\operatorname{val}(f)=f^{\text{out}}(s)\)</span>. For any <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut <span class="math notranslate nohighlight">\(c(A,B)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, the value of the flow <span class="math notranslate nohighlight">\(f\)</span> can be computed as</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{val}(f) = f^{\text{out}}(A) - f^{\text{in}}(A)
  \]</div>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof</em></p>
<p>Let <span class="math notranslate nohighlight">\(f(u,v)=0\)</span> if there is no edge between two vertices <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\operatorname{val}(f)
&amp; = f^{\text{out} }(s) \\
&amp;= \sum_{u \in A} \left[ f^{\text{out}}(u) - f^{\text{in}}(u) \right] \\
&amp;= \sum_{u \in A} \left[ \sum_{v} f(u,v) - \sum_{v} f(v,u) \right] \\\\
&amp;= \sum_{u \in A, v \in A}  f(u,v) + \sum_{u \in A, v \in B}  f(u,v) - \sum_{u \in A, v \in A} f(v,u) - \sum_{u \in A, v \in B} f(v,u)  \\\\
&amp;= \sum_{u \in A, v \in B}  f(u,v) - \sum_{u \in A, v \in B} f(v,u)  \\\\
&amp;= f^{\text{out}}(A)- f^{\text{in}}(A)  \\\\
\end{aligned}\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>This corollary is the key for subsequent analysis</p>
</div>
<dl class="simple myst">
<dt>Corollary</dt><dd><p><span class="math notranslate nohighlight">\(\operatorname{val}(f) \le c(A,B)\)</span>, with equality iff <span class="math notranslate nohighlight">\(f^{\text{in}}(A) = 0\)</span> and <span class="math notranslate nohighlight">\(f^{\text{out}}(A) = c(A,B)\)</span>.</p>
</dd>
<dt>Theorem</dt><dd><p>If <span class="math notranslate nohighlight">\(f\)</span> is any <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> flow and <span class="math notranslate nohighlight">\((A,B)\)</span> is any <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut, and <span class="math notranslate nohighlight">\(\operatorname{val}(f) = c(A,B)\)</span>, then <span class="math notranslate nohighlight">\(f\)</span> is a maximum flow, by Corollary.</p>
</dd>
</dl>
<p>How about existence?</p>
<dl class="simple myst">
<dt>Claim (Optimality)</dt><dd><p>If <span class="math notranslate nohighlight">\(f\)</span> is the flow returned by FF algorithm, then there exists an <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span> such that <span class="math notranslate nohighlight">\(\operatorname{val}(f) = c(A,B)\)</span>. So <span class="math notranslate nohighlight">\(f\)</span> is optimal by the above theorem.</p>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof</em></p>
<p>Recall that FF algorithm stops if there is no <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> path. After it stops, consider a cut <span class="math notranslate nohighlight">\((A,B)\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span>, where <span class="math notranslate nohighlight">\(A\)</span> is the set of all vertices <span class="math notranslate nohighlight">\(v \in V\)</span> such that there is an <span class="math notranslate nohighlight">\(s-v\)</span> path in <span class="math notranslate nohighlight">\(G_f\)</span>, and all other vertices (e.g., <span class="math notranslate nohighlight">\(t\)</span>) are in <span class="math notranslate nohighlight">\(B\)</span>. By this definition, there is no edge from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Now, for the cut <span class="math notranslate nohighlight">\((A,B)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, we want to prove</p>
<div class="math notranslate nohighlight">
\[
\operatorname{val}(f) = c(A,B)
\]</div>
<p>By Corollary, this holds iff <span class="math notranslate nohighlight">\(f^{\text{in}}(A) = 0\)</span> and <span class="math notranslate nohighlight">\(f^{\text{out}}(A) = c(A,B)\)</span>. Equivalently,</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\forall e^+ \in \delta^+(A), f(e^+) = c(e^+)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\forall e^- \in \delta^-(A), f(e^-) = 0 \\\)</span></p></li>
</ol>
<p>These two conditions are indeed satisfied when FF algorithm stops.</p>
<ol class="simple">
<li><p>If there exists <span class="math notranslate nohighlight">\(e^+ = (a,b): f(e^+) &lt; c(e^+)\)</span>, then there is an forward edge <span class="math notranslate nohighlight">\((a,b)\)</span> from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span> with residual capacity <span class="math notranslate nohighlight">\(c_f(a,b) = c(e^+) - f(e^+)&gt;0\)</span>, contradiction to the stoping condition of <span class="math notranslate nohighlight">\(G_f\)</span>.</p></li>
<li><p>If there exists <span class="math notranslate nohighlight">\(e^- = (b,a): f(e^-) &gt; 0\)</span>, then there is an edge <span class="math notranslate nohighlight">\((a,b)\)</span> from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span> with residual capacity <span class="math notranslate nohighlight">\(c_f(a,b) &gt; 0\)</span>, contradiction to the stoping condition of <span class="math notranslate nohighlight">\(G_f\)</span>.</p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
</div>
<div class="section" id="complexity">
<h3>Complexity<a class="headerlink" href="#complexity" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math notranslate nohighlight">\(m\)</span> be the number of edges in the graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Recall that there are at most <span class="math notranslate nohighlight">\(\sum_{v\in \operatorname{succ}(s)} c(s, v)\)</span> iterations. The bound is upper bounded by <span class="math notranslate nohighlight">\(n \times c _{\max}(e)\)</span>.</p>
<p>In each iteration</p>
<ul class="simple">
<li><p>Finding augmenting path <span class="math notranslate nohighlight">\(P\)</span> takes <span class="math notranslate nohighlight">\(O(m)\)</span></p></li>
<li><p>Pushing flow along <span class="math notranslate nohighlight">\(P\)</span> takes <span class="math notranslate nohighlight">\(O(m)\)</span></p></li>
<li><p>Recompute <span class="math notranslate nohighlight">\(G_f\)</span> takes <span class="math notranslate nohighlight">\(O(m)\)</span></p></li>
</ul>
<p>So the total running time is <span class="math notranslate nohighlight">\(O(m\cdot n\cdot c _{\max})\)</span></p>
<div class="note admonition">
<p class="admonition-title"> Is FF algorithm efficient?</p>
<p>There are two inputs.</p>
<ul class="simple">
<li><p>Graph, which is a combinatorial part of size <span class="math notranslate nohighlight">\((n,m)\)</span></p></li>
<li><p>Capacities, which is a numerical part of size <span class="math notranslate nohighlight">\(m\)</span></p></li>
</ul>
<p>Recall different running time</p>
<ul class="simple">
<li><p>strong-polynomial time: <span class="math notranslate nohighlight">\(Poly(\text{input size of the combinatorial part})\)</span>, e.g. <span class="math notranslate nohighlight">\(O(n)\)</span></p></li>
<li><p>weak-polynomial time: <span class="math notranslate nohighlight">\(Poly(\text{input sizes of both parts})\)</span>, e.g. <span class="math notranslate nohighlight">\(O(n \log c_\max)\)</span></p></li>
<li><p>pseudo-polynomial time: <span class="math notranslate nohighlight">\(Poly(\text{the largest integer present in the input})\)</span>, e.g. <span class="math notranslate nohighlight">\(O(c_\max)\)</span></p></li>
</ul>
</div>
</div>
<div class="section" id="improvement-edmonds-karp-algorithm">
<h3>Improvement: Edmonds-Karp Algorithm<a class="headerlink" href="#improvement-edmonds-karp-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Instead of using an arbitrary augmenting path, we use the <strong>shortest</strong> path <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\(G\)</span> that minimizes number of edges. This work takes <span class="math notranslate nohighlight">\(O(m)\)</span> by BFS or DFS, so each iteration still takes <span class="math notranslate nohighlight">\(O(m)\)</span>. But it reduces the number of iterations from <span class="math notranslate nohighlight">\(O(nc_\max)\)</span> to <span class="math notranslate nohighlight">\(O(nm)\)</span>, this leads to the Edmonds-Karp algorithm with complexity <span class="math notranslate nohighlight">\(O(nm^2)\)</span>.</p>
<p>To show that, we first run that algorithm, record the length of the chosen shortest path in each iteration, and then partition these the execution into phases, where each phase lasts as long as the lengths of augmenting paths chosen remains the same.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\text{iteration} &amp;\quad 1 \quad2 \ \quad 3 \  \quad4 \ \quad 5 \quad6 \quad 7\\
\text{shortest path length} &amp;\quad \underbrace{2 \quad 2}_{\text{phase 1} } \quad \underbrace{3\quad 3}_{\text{phase 2} } \quad \underbrace{5 \quad 5 \quad 5}_{\text{phase 3} }  \\
\end{aligned}\end{split}\]</div>
<dl class="simple myst">
<dt>Claim (Non-decreasing shortest path length)</dt><dd><p>From iteration to iteration, the length of the augmenting path is non-decreasing. Hence, the number of phases is at most <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd>
<dt>Claim (<span class="math notranslate nohighlight">\(O(m)\)</span> iterations in each phase)</dt><dd><p>Every phase covers at most <span class="math notranslate nohighlight">\(O(m)\)</span> iterations.</p>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof</em></p>
<p>To prove them, let <span class="math notranslate nohighlight">\(G_f\)</span> be the residual graph at the <em>start</em> of iteration <span class="math notranslate nohighlight">\(i\)</span>, and <span class="math notranslate nohighlight">\(G_f ^\prime\)</span> be the residual path at the <em>end</em> of iteration <span class="math notranslate nohighlight">\(i\)</span>, and <span class="math notranslate nohighlight">\(P\)</span> be the augmenting path in iteration <span class="math notranslate nohighlight">\(i\)</span>. From the algorithm we observe that</p>
<ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(e \in E(G_f)\)</span> but <span class="math notranslate nohighlight">\(e \notin E(G_f ^\prime)\)</span>, then <span class="math notranslate nohighlight">\(e \in E(P)\)</span></p></li>
<li><p>at least one edge <span class="math notranslate nohighlight">\(e\in P\)</span> has to disappear in <span class="math notranslate nohighlight">\(G ^\prime _f\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(e \notin E(G_f)\)</span> but <span class="math notranslate nohighlight">\(e \in E(G_f ^\prime)\)</span> then its anti-parallel edge <span class="math notranslate nohighlight">\(e ^\prime  \in E(P)\)</span>.</p></li>
</ul>
<p>Now consider using BFS from to find a shortest path <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span>. Suppose the path length is <span class="math notranslate nohighlight">\(d\)</span>, then there are <span class="math notranslate nohighlight">\(d+1\)</span> layers. The first layers only contains <span class="math notranslate nohighlight">\(s\)</span>, and the last layer contains <span class="math notranslate nohighlight">\(t\)</span>. In each iteration, we delete some forward-looking edge, and add a backward-looking edge or sideways-looking edge, but <strong>no</strong> shortcut edge. So the shortest path is non-decreasing. Beside, there are at most <span class="math notranslate nohighlight">\(m\)</span> layers to delete in a phase with path length <span class="math notranslate nohighlight">\(d\)</span>, so at most <span class="math notranslate nohighlight">\(O(m)\)</span> iterations in that phase.</p>
<div class="figure align-default" id="max-flow-bfs">
<a class="reference internal image-reference" href="../_images/max-flow-bfs.png"><img alt="" src="../_images/max-flow-bfs.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Fig. 28 </span><span class="caption-text">BFS in <span class="math notranslate nohighlight">\(G_f\)</span> [Chuzhoy 2021]</span><a class="headerlink" href="#max-flow-bfs" title="Permalink to this image">¶</a></p>
</div>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
</div>
<div class="section" id="approximation">
<h3>Approximation<a class="headerlink" href="#approximation" title="Permalink to this headline">¶</a></h3>
<p><span class="math notranslate nohighlight">\((1+\epsilon)\)</span>-approximation returns a flow of value at least <span class="math notranslate nohighlight">\(\frac{OPT}{1+\epsilon}\)</span>.</p>
</div>
<div class="section" id="other-properties">
<h3>Other Properties<a class="headerlink" href="#other-properties" title="Permalink to this headline">¶</a></h3>
<dl class="simple myst">
<dt>Theorem (Integrality of flow)</dt><dd><p>If all capacities are integrals, then the Ford-Fulkerson algorithm finds a maximum flow where <span class="math notranslate nohighlight">\(f(e)\)</span> is integral for all <span class="math notranslate nohighlight">\(e\)</span>.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="minimum-cut">
<h2>Minimum Cut<a class="headerlink" href="#minimum-cut" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>Problem<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p><strong>Input</strong></p>
<ul class="simple">
<li><p>A directed graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>.</p></li>
<li><p>Capacity <span class="math notranslate nohighlight">\(c(e)\)</span>.</p></li>
<li><p>Two special vertices <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
<p><strong>Goal</strong></p>
<p>Find an <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span> where <span class="math notranslate nohighlight">\(s \in A, t \in B\)</span>, with minimal cut capacity <span class="math notranslate nohighlight">\(c(A,B)\)</span>, which is the sum of capacities of edge from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span>, <span class="math notranslate nohighlight">\(c(A, B) = \sum_{u\in A, v\in B} c(u,v)\)</span>.</p>
<p>In other words, we want to remove some edges to <strong>disconnect</strong> <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span>, and minimize the total capacities of these removed edges. The vertex partition’s perspective and edge removal’s perspective are equivalent.</p>
</div>
<div class="section" id="id3">
<h3>Analysis<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<dl class="simple myst">
<dt>Theorem (Equivalency of maximum flow and minimum cut)</dt><dd><p>In any flow network <span class="math notranslate nohighlight">\(G\)</span>, the value of a maximum <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> flow is equal to the capacity of a minimum <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut.</p>
</dd>
</dl>
<p>The proof is simply from the Corollary.</p>
<p>Thus, FF algorithm also gives an algorithm for finding a minimum <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut: after the algorithm stops, in the residual graph <span class="math notranslate nohighlight">\(G_f\)</span>, find the set of vertices reachable from <span class="math notranslate nohighlight">\(s\)</span>, then <span class="math notranslate nohighlight">\((A, V\setminus B)\)</span> is a minimum <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut.</p>
</div>
</div>
<div class="section" id="extension">
<h2>Extension<a class="headerlink" href="#extension" title="Permalink to this headline">¶</a></h2>
<p><span class="math notranslate nohighlight">\(O(m n c_\max)\)</span> is not efficient. There are alternative algorithms to improve this.</p>
<div class="section" id="max-flow-and-min-cut-in-undirected-graphs">
<h3>Max-flow and Min-cut in Undirected Graphs<a class="headerlink" href="#max-flow-and-min-cut-in-undirected-graphs" title="Permalink to this headline">¶</a></h3>
<p>To find maximum <span class="math notranslate nohighlight">\(s-t\)</span> flow in undirected graph with capacities <span class="math notranslate nohighlight">\(c(e)&gt;0\)</span>, we can make the graph directed, and run Ford-Fulkerson algorithm on the directed counterpart.</p>
<ul>
<li><p>Convert every undirected edge to two anti-parallel directed edges with the same capacity as the undirected edge.</p>
<div class="math notranslate nohighlight">
\[u - v \quad \Rightarrow \quad  u \leftrightarrows v\]</div>
</li>
<li><p>Run the Ford-Fulkerson algorithm for directed graph.</p></li>
<li><p>Finally, run flow cancelation for two anti-parallel edges, such that one of the two anti-parallel edges is reduced to 0.</p>
<div class="math notranslate nohighlight">
\[u \leftrightarrows v \quad \Rightarrow \quad  u \rightarrow v \text{ or } u \leftarrow v\]</div>
</li>
</ul>
<p>The direction of an edge indicates the direction of flow (e.g. pipeline) in the undirected graph. The final flow value are the same, and the integrality of max-flow also holds.</p>
<p>Meanwhile, we can find a minimum cut on a undirected graph, the capacity/cost of the cut is the sum of the capacities of the edges across <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>.</p>
<div class="math notranslate nohighlight">
\[
\sum _{e \in E(A,B)} c(e)
\]</div>
<p>Likewise, we convert every undirected edge to two anti-parallel directed edges, run Ford-Fulkerson algorithm to find a <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span>. The cut values are the same.</p>
<p>Since in the directed graph we have max-flow <span class="math notranslate nohighlight">\(=\)</span> min-cut, in the undirected graph we have max-flow <span class="math notranslate nohighlight">\(=\)</span> min-cut.</p>
</div>
<div class="section" id="minimum-cost-flow">
<h3>Minimum Cost Flow<a class="headerlink" href="#minimum-cost-flow" title="Permalink to this headline">¶</a></h3>
<p>Input: a directed graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>, vertices <span class="math notranslate nohighlight">\(s, t \in V\)</span>, capacities <span class="math notranslate nohighlight">\(c(e)\)</span> and weights <span class="math notranslate nohighlight">\(w(e)\)</span>.</p>
<p>Goal: send maximum amount of flow from <span class="math notranslate nohighlight">\(s\)</span> to <span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, with minimum possible cost, where for each edge <span class="math notranslate nohighlight">\(e\)</span>, we need to pay <span class="math notranslate nohighlight">\(w(e)\)</span> for every unit of flow sent over edge <span class="math notranslate nohighlight">\(e\)</span>.</p>
<p>Solution: First find the value <span class="math notranslate nohighlight">\(d\)</span> of an <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> max-flow in <span class="math notranslate nohighlight">\(G\)</span> (using Ford-Fulkerson algorithm or LP). Then solve the following LP. The variables are <span class="math notranslate nohighlight">\(f(e)\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\operatorname{minimize} &amp;&amp; \sum_{e \in E} w(e) f(e) &amp; &amp;&amp;\\
\mathrm{s.t.} &amp;&amp; f(e) &amp;\leq c(e) &amp;&amp; \forall e \in E \\
&amp;&amp; \sum_{e \in \delta^{+}(v)} f(e)-\sum_{e \in \delta^{-}(v)} f(e)&amp;=0 &amp;&amp; \forall v \in V \backslash\{s, t\} \\
&amp;&amp;\sum_{e \in \delta^{+}(s)} f(e)&amp; =d &amp;&amp; \\
&amp;&amp; f(e) &amp;\geq 0 &amp;&amp; \forall e \in E
\end{aligned}\end{split}\]</div>
<p>Can you solve the problem by solving a single LP (instead of first computing the value <span class="math notranslate nohighlight">\(d\)</span>
and then solving an LP that depends on the value <span class="math notranslate nohighlight">\(d\)</span>)??</p>
</div>
<div class="section" id="s-t-shortest-path">
<h3><span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> Shortest Path<a class="headerlink" href="#s-t-shortest-path" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="path-based-flow">
<h3>Path-based Flow<a class="headerlink" href="#path-based-flow" title="Permalink to this headline">¶</a></h3>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Aka flow-paths.</p>
</div>
<p>Recall the flow <span class="math notranslate nohighlight">\(f: V\rightarrow \mathbb{R} _{\ge 0}\)</span> is defined for edges. We can consider a path-based flow <span class="math notranslate nohighlight">\(f_{p} : \mathcal{P}\rightarrow \mathbb{R} _{\ge 0}\)</span>, where <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> is the set of some <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> paths. Let <span class="math notranslate nohighlight">\(f _{p} (P)\)</span> be the flow of a path <span class="math notranslate nohighlight">\(P \in \mathcal{P}\)</span>. It is valid if the edge capacity constraint holds.</p>
<div class="math notranslate nohighlight">
\[
\forall e:\quad \sum_{P: P \in \mathcal{P} \text{ and } E(P) \ni e} f _{p} (P) \le c(e)
\]</div>
<p>The set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> and the flow assignment <span class="math notranslate nohighlight">\(f_p\)</span> together are called a flow-paths solution, with value <span class="math notranslate nohighlight">\(\sum_{P \in \mathcal{P}}f _{p} (P)\)</span>.</p>
<dl class="simple myst">
<dt>Theorem (Equivalence of edge-flow and path-flow)</dt><dd><p>Given an edge-based flow <span class="math notranslate nohighlight">\(\left\{ f(e) \right\}_{e \in E}\)</span>, we can compute the path-based flow <span class="math notranslate nohighlight">\(\left\{ f _{p} (P) \right\}_{P \in \mathcal{P}}\)</span> efficiently, and</p>
<ul class="simple">
<li><p>They have the same flow values <span class="math notranslate nohighlight">\(\sum_{e \in \delta^+(s)} f(e)=\sum_{P \in \mathcal{P}}f _{p} (P)\)</span></p></li>
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> is feasible, then , and <span class="math notranslate nohighlight">\(f _{p}\)</span> is also feasible.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> is integral, then <span class="math notranslate nohighlight">\(f _{p}\)</span> is also integral.</p></li>
</ul>
<p>And the reverse also hold.</p>
</dd>
<dt>Theorem (Flow decomposition)</dt><dd><p>Any <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> flow can decompose into at most <span class="math notranslate nohighlight">\(m\)</span> number of cycles and <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> paths.</p>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof</em></p>
<p>We provide an efficient algorithm for such decomposition.</p>
<p>Let <span class="math notranslate nohighlight">\((a,b)\)</span> be an edge with <span class="math notranslate nohighlight">\(f(a,b)&gt;0\)</span>. Then trace backward from <span class="math notranslate nohighlight">\(a\)</span>, and trace forward from <span class="math notranslate nohighlight">\(b\)</span>, along edges with positive flow <span class="math notranslate nohighlight">\(f(e)&gt;0\)</span>.</p>
<div class="math notranslate nohighlight">
\[\cdots a \rightarrow b \cdots\]</div>
<p>Until we reach</p>
<ul class="simple">
<li><p>a cycle (along <span class="math notranslate nohighlight">\(a\)</span>, along <span class="math notranslate nohighlight">\(b\)</span>, or involve edge <span class="math notranslate nohighlight">\((a,b)\)</span>), or</p></li>
<li><p>both <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span></p></li>
</ul>
<p>Let <span class="math notranslate nohighlight">\(W\)</span> be the edges in cycle or <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> path. Compute <span class="math notranslate nohighlight">\(\Delta = \min_{e \in E(W)} f(e)\)</span>. Subtract <span class="math notranslate nohighlight">\(\Delta\)</span> from all flow of edges in <span class="math notranslate nohighlight">\(W\)</span>. The resulted flow is also valid, and the flow value remains unchanged.</p>
<p>We repeat this process until there is no cycle or path. Each iteration reduces flow to one edge to 0, so the number of iterations is at most <span class="math notranslate nohighlight">\(m\)</span>. Each iteration gives a cycle or <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> path with flow <span class="math notranslate nohighlight">\(\Delta\)</span>. Hence, the number of cycles and <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> paths is at most <span class="math notranslate nohighlight">\(m\)</span>.</p>
<p>Each iteration takes <span class="math notranslate nohighlight">\(O(m)\)</span>, so total running time is <span class="math notranslate nohighlight">\(O(m^2)\)</span>.</p>
</div>
<p>Note that dropping the cycles does not affect the flow value. Thus, the paths obtained from this algorithm together with their <span class="math notranslate nohighlight">\(\Delta\)</span> form a valid flow-paths solution, which means we can solve path-based max-flow by solving edge-based max-flow, and then converting it. The original path-based flow has exponential number of variables and constraints in <span class="math notranslate nohighlight">\(n\)</span>, but it can be solved by the Ellipsoid Algorithm together with a separation oracle.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{rcc}
\operatorname{maximize} &amp; \sum_{P \in \mathcal{P}} f_p(P) &amp; \\
\text { s.t. } &amp; \sum_{P: e \in P} f_p(P) \leq c(e) &amp; \forall e \in E \\
&amp; f_p(P) \geq 0 &amp; \forall P \in \mathcal{P}
\end{array}
\end{split}\]</div>
</div>
<div class="section" id="edge-disjoint-paths">
<h3>Edge-Disjoint Paths<a class="headerlink" href="#edge-disjoint-paths" title="Permalink to this headline">¶</a></h3>
<p>Ford-Fulkerson algorithm is an efficient algorithm for finding edge-disjoint paths problem in directed graph.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Edge-disjoint path = EDP</p>
</div>
<p><strong>Problem</strong>: For a directed graph with two disjoint <strong>sets</strong> of vertices <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span>, we want to find a maximum-cardinality set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> of <span class="math notranslate nohighlight">\(S\)</span>-<span class="math notranslate nohighlight">\(T\)</span> paths that are edge-disjoint, i.e. no path in <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> can share any edges.</p>
<p>To solve this,</p>
<ol>
<li><p>For every edge <span class="math notranslate nohighlight">\(e\in G\)</span>, set capacity <span class="math notranslate nohighlight">\(c(e)=1\)</span>. Add one node <span class="math notranslate nohighlight">\(s\)</span> that connects to every vertex <span class="math notranslate nohighlight">\(u\)</span> in <span class="math notranslate nohighlight">\(S\)</span> with capacity <span class="math notranslate nohighlight">\(\infty\)</span>. Add one node <span class="math notranslate nohighlight">\(t\)</span> that connects to every vertex <span class="math notranslate nohighlight">\(v\)</span> in <span class="math notranslate nohighlight">\(T\)</span> with capacity <span class="math notranslate nohighlight">\(\infty\)</span>. Call this flow network <span class="math notranslate nohighlight">\(H\)</span>.</p>
<div class="math notranslate nohighlight">
\[
    s \overset{\infty}{-} S \cdots T \overset{\infty}{-} t
    \]</div>
</li>
<li><p>Run Ford-Fulkerson algorithm on <span class="math notranslate nohighlight">\(H\)</span> to obtain a flow <span class="math notranslate nohighlight">\(f\)</span>. Since <span class="math notranslate nohighlight">\(f(e)\le c(e)=1\)</span> and is integral, it is 1.</p></li>
<li><p>Run flow-path decomposition, then each path also carries path-flow value 1. When we delete the path, we actually remove all edges along the path since <span class="math notranslate nohighlight">\(c(e)=1\)</span>. Moreover, the subsequent paths must be disjoint with this one since <span class="math notranslate nohighlight">\(c(e)=1\)</span>. We will get a collection of EDP from <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(T\)</span>. The number of paths equals to the flow value.</p></li>
</ol>
</div>
<div class="section" id="s-t-cut">
<h3><span class="math notranslate nohighlight">\(S\)</span>-<span class="math notranslate nohighlight">\(T\)</span> Cut<a class="headerlink" href="#s-t-cut" title="Permalink to this headline">¶</a></h3>
<p><strong>Problem</strong>: Given two sets of vertices <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span> in a directed graph <span class="math notranslate nohighlight">\(G\)</span>, what is the minimum number of edges needed to disconnect <span class="math notranslate nohighlight">\(S\)</span> from <span class="math notranslate nohighlight">\(T\)</span>? Formally, find a minimum-cardinality edge set <span class="math notranslate nohighlight">\(E ^\prime \subseteq E\)</span> such that in the remaining graph <span class="math notranslate nohighlight">\(G \setminus E ^\prime\)</span>, there is <strong>no</strong> path from a vertex of <span class="math notranslate nohighlight">\(S\)</span> to a vertex of <span class="math notranslate nohighlight">\(T\)</span>.</p>
<dl class="simple myst">
<dt>Menger’s Theorem</dt><dd><p>The maximum number of EDPs connecting <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(T\)</span> is equal to the minimum number of edges needed to disconnect <span class="math notranslate nohighlight">\(S\)</span> from <span class="math notranslate nohighlight">\(T\)</span>.</p>
</dd>
</dl>
<p>The same can be done for undirected graphs.</p>
</div>
<div class="section" id="vertex-capacitated-max-flow">
<h3>Vertex-capacitated Max Flow<a class="headerlink" href="#vertex-capacitated-max-flow" title="Permalink to this headline">¶</a></h3>
<p>In reality, capacities are often defined on vertices, such as computer networks. Each vertex has capacity constraint <span class="math notranslate nohighlight">\(c(v)\)</span>. The capacity constraints are on vertices: the total inflow into any vertex <span class="math notranslate nohighlight">\(v\)</span> is at most <span class="math notranslate nohighlight">\(c(v)\)</span>. The conservation becomes: for each vertex, outflow = inflow. How to find a maximum flow?</p>
<p>We reduce this problem to the usual max flow problem buy convert an vertex-capacitated max flow problem instance <span class="math notranslate nohighlight">\(I_V\)</span> into an edge-capacitated problem instance <span class="math notranslate nohighlight">\(I_E\)</span>, and show that we can solve <span class="math notranslate nohighlight">\(I_V\)</span> by solving <span class="math notranslate nohighlight">\(I_E\)</span>.</p>
<ul class="simple">
<li><p>replace node <span class="math notranslate nohighlight">\(v \in V \setminus \left\{ s,t \right\}\)</span> by two nodes <span class="math notranslate nohighlight">\(v_{in}\)</span> and <span class="math notranslate nohighlight">\(v_{out}\)</span></p></li>
<li><p>replace edge <span class="math notranslate nohighlight">\((u,v)\)</span> by <span class="math notranslate nohighlight">\((u_{out}, v_{in})\)</span></p>
<ul>
<li><p>replace edge <span class="math notranslate nohighlight">\((s,v)\)</span> by <span class="math notranslate nohighlight">\((s, v_{in})\)</span></p></li>
<li><p>replace edge <span class="math notranslate nohighlight">\((v,t)\)</span> by <span class="math notranslate nohighlight">\((v_{out}, t)\)</span></p></li>
<li><p>assign these edge infinite capacities</p></li>
</ul>
</li>
<li><p>add edge <span class="math notranslate nohighlight">\((v_{in}, v_{out})\)</span> with capacity <span class="math notranslate nohighlight">\(c(v)\)</span></p></li>
</ul>
<p>Given a flow <span class="math notranslate nohighlight">\(f_V\)</span> on <span class="math notranslate nohighlight">\(I_V\)</span>, transform it into a flow <span class="math notranslate nohighlight">\(f_E\)</span> for <span class="math notranslate nohighlight">\(I_E\)</span> by</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
f _E (u_{out}, v_{in}) &amp;= f_V(u, v) \\
f _E (v_{out}, t) &amp;= f_V(v, t) \\
f _E (s, v_{in}) &amp;= f_V(s, v) \\
f _E (v_{in}, v_{out}) &amp;= \sum_{u:(u,v) \in E} f_V(u, v) \\
\end{aligned}\end{split}\]</div>
<p>In this way, <span class="math notranslate nohighlight">\(f _E\)</span> is a valid flow, and values of flow for <span class="math notranslate nohighlight">\(f_V\)</span> and <span class="math notranslate nohighlight">\(f_E\)</span> are <span class="math notranslate nohighlight">\(\sum_{v:(s, v) \in E\left(I_{V}\right)} f_V(s, v)\)</span> and <span class="math notranslate nohighlight">\(\sum_{v_{i n}:\left(s, v_{i n}\right) \in E\left(I_{E}\right)} f_E\left(s, v_{i n}\right)\)</span> respectively.</p>
<p>In the other direction, given <span class="math notranslate nohighlight">\(f_E\)</span>, we can construct <span class="math notranslate nohighlight">\(f\)</span> by similar rules as above. Vertex capacity constraints will be satisfied by inflow into a vertex <span class="math notranslate nohighlight">\(v\)</span>, which must be at most <span class="math notranslate nohighlight">\(c(v)\)</span> as <span class="math notranslate nohighlight">\(f_E\)</span> is valid.</p>
<p>Algorithmically, given <span class="math notranslate nohighlight">\(I_V\)</span>, we construct instance <span class="math notranslate nohighlight">\(I_E\)</span>, run Fold-Fulkerson algorithm on <span class="math notranslate nohighlight">\(I_E\)</span> to obtain optimal flow <span class="math notranslate nohighlight">\(f_E\)</span>, and convert the flow <span class="math notranslate nohighlight">\(f_E\)</span> into an optimal <span class="math notranslate nohighlight">\(f_V\)</span> for <span class="math notranslate nohighlight">\(I_V\)</span> as described above.</p>
<p>Other problems under this setting:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut:</p>
<p>Find a minimum cardinality subet <span class="math notranslate nohighlight">\(V ^\prime \subseteq V \setminus \left\{ s,t \right\}\)</span> such that <span class="math notranslate nohighlight">\(G \setminus V ^\prime\)</span> hs no <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> path. Proof: show that any edge cut in <span class="math notranslate nohighlight">\(I_E\)</span> corresponds to a vertex cut in <span class="math notranslate nohighlight">\(I_V\)</span> of the same value, and vice versa.</p>
</li>
<li><p>max-flow min-cut:</p>
<p><span class="math notranslate nohighlight">\(\operatorname{Max}\)</span>-<span class="math notranslate nohighlight">\(\operatorname{flow}\left(I_{V}\right)=\operatorname{Max}\)</span>-<span class="math notranslate nohighlight">\(\operatorname{Mow}\left(I_{E}\right)=\operatorname{Min}\)</span>-<span class="math notranslate nohighlight">\(\operatorname{cut}\left(I_{E}\right)=\operatorname{Min}\)</span>-<span class="math notranslate nohighlight">\(\operatorname{cut}\left(I_{V}\right)\)</span></p>
</li>
<li><p>Menger’s Theorem</p>
<p>The maximum number of vertex-disjoint path connecting <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(T\)</span> is equal to the minimum number of vertices needed to remove to disconnect <span class="math notranslate nohighlight">\(S\)</span> from <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>Create a super-source <span class="math notranslate nohighlight">\(s\)</span> and a super sink <span class="math notranslate nohighlight">\(t\)</span> connected respectively to all vertices of <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span>. Give every other vertex (except <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span>) a capacity of 1. Then max-fow equals maximum number of node disjoint paths between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span> and min-cut equals minimum cardinality subset we remove to disconnect <span class="math notranslate nohighlight">\(S,T\)</span>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="applications">
<h2>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">¶</a></h2>
<div class="section" id="image-segmentation">
<h3>Image Segmentation<a class="headerlink" href="#image-segmentation" title="Permalink to this headline">¶</a></h3>
<p>An image can be viewed as a vertex. We want to partition an image into two parts, e.g. foreground and background. For pixel/vertex <span class="math notranslate nohighlight">\(s\)</span>, let <span class="math notranslate nohighlight">\(a_v\)</span> be how likely <span class="math notranslate nohighlight">\(v\)</span> to be in a part, and <span class="math notranslate nohighlight">\(b_v\)</span> be how likely <span class="math notranslate nohighlight">\(v\)</span> to be in the other part.</p>
<p>To solve this, we define strength/similarity for every pair of pixels <span class="math notranslate nohighlight">\(s_{u,v}\)</span>. The ultimate task is to partition the pixels into two sets <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>. The similarity of two pixels from different partition should be small. The objective is</p>
<div class="math notranslate nohighlight">
\[
\max \left\{ \sum_{v \in X} a_v  + \sum_{u \in Y} b_u  - \sum_{v \in X, u\in Y} s_{v,u}  \right\}
\]</div>
<p>which is equivalent to</p>
<div class="math notranslate nohighlight">
\[
\min \left\{ \sum_{v \in X, u\in Y} P_{v,u}  - \sum_{v \in X} a_v  - \sum_{u \in Y} b_u  \right\}
\]</div>
<p>which is equivalent to</p>
<div class="math notranslate nohighlight">
\[
\min \left\{ \sum_{v \in X, u\in Y} s_{v,u}  - \sum_{v \in X} a_v  - \sum_{u \in Y} b_u + \sum_{w \in V} (a_w + b_w) \right\}
\]</div>
<p>which is</p>
<div class="math notranslate nohighlight">
\[
\min \left\{ \sum_{v \in X, u\in Y} s_{v,u}  + \sum_{v \in Y} a_v  + \sum_{u \in X} b_u \right\}
\]</div>
<p>We can solve this with minimum cut on undirected graph. The capacity of an edge is the strength of that edge. For every vertex <span class="math notranslate nohighlight">\(v\)</span>, add edge <span class="math notranslate nohighlight">\((s,v)\)</span> of capacity <span class="math notranslate nohighlight">\(a_v\)</span>, and edge <span class="math notranslate nohighlight">\((v, t)\)</span> of capacity <span class="math notranslate nohighlight">\(b_v\)</span>. Also for add edge <span class="math notranslate nohighlight">\(e(v,u)\)</span> of capacity <span class="math notranslate nohighlight">\(s_{v,u}\)</span> for <span class="math notranslate nohighlight">\(u,v \ne s,t\)</span>. Consider an <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span>, denote <span class="math notranslate nohighlight">\(X = A \backslash \left\{ s \right\}\)</span> and <span class="math notranslate nohighlight">\(Y = B \backslash \left\{ t \right\}\)</span>.</p>
<dl class="simple myst">
<dt>Claim</dt><dd><p>The capacity of the cut equals the value of the objective function. So the optimization problem in image segmentation can be solved by the minimum cut problem.</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[
c(A,B) = \sum _{e \in E(A,B)} c(e) = f(X,Y)
\]</div>
<p><em><strong>Proof</strong></em></p>
<p>There are 3 kinds of across-set edges in <span class="math notranslate nohighlight">\(E(A, B)\)</span></p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(e=(u,v), u\ne s, v\ne t\)</span>, contribute <span class="math notranslate nohighlight">\(s_e\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(e=(s,x), x\in B \backslash \left\{ t \right\}\)</span> with edge capacity <span class="math notranslate nohighlight">\(a_x\)</span>. Total contribute <span class="math notranslate nohighlight">\(\sum_{x \in Y} a_x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(e=(y,t), y\in A \backslash \left\{ s \right\}\)</span> with edge capacity <span class="math notranslate nohighlight">\(a_x\)</span>. Total contribute <span class="math notranslate nohighlight">\(\sum_{b \in X} b_y\)</span></p></li>
</ol>
<p>Hence</p>
<div class="math notranslate nohighlight">
\[
c(A,B) = \sum_{v \in X, u\in Y} s_{v,u}  + \sum_{v \in Y} a_v  + \sum_{u \in X} b_u
\]</div>
<p>which is exactly the objective function.</p>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
</div>
<div class="section" id="exercise">
<h2>Exercise<a class="headerlink" href="#exercise" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be an arbitrary (directed) flow network with integral edge capacities</p>
<ol>
<li><p>[<strong>Change of capacity</strong>] Prove or disapprove:</p>
<ol class="simple">
<li><p>Let <span class="math notranslate nohighlight">\(e=(u,v)\)</span> be an edge of <span class="math notranslate nohighlight">\(G\)</span> with capacity <span class="math notranslate nohighlight">\(c(e) ≥ 1\)</span>. <strong>Decreasing</strong> the capacity of an edge <span class="math notranslate nohighlight">\(e\)</span> by <span class="math notranslate nohighlight">\(1\)</span> decreases the maximum flow value by at most <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(e=(u,v)\)</span> be an edge of <span class="math notranslate nohighlight">\(G\)</span> with capacity <span class="math notranslate nohighlight">\(c(e) ≥ k\)</span> where <span class="math notranslate nohighlight">\(k\)</span> is a positive integer. <strong>Decreasing</strong> the capacity of an edge <span class="math notranslate nohighlight">\(e\)</span> by <span class="math notranslate nohighlight">\(k\)</span> decreases the maximum flow value by at most <span class="math notranslate nohighlight">\(k\)</span>.</p></li>
<li><p><strong>Increasing</strong> the capacity of an edge <span class="math notranslate nohighlight">\(e\)</span> by <span class="math notranslate nohighlight">\(1\)</span> increases the maximum flow value by at most <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
<li><p><strong>Increasing</strong> the capacity of an edge <span class="math notranslate nohighlight">\(e\)</span> by a positive integer <span class="math notranslate nohighlight">\(k\)</span> increases  the maximum flow value by at most <span class="math notranslate nohighlight">\(k\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\((A,B)\)</span> be a minimum <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut in G. If we <strong>increase</strong> the capacity of <strong>each</strong> edge in <span class="math notranslate nohighlight">\(E(G)\)</span> by <span class="math notranslate nohighlight">\(1\)</span>, then <span class="math notranslate nohighlight">\((A,B)\)</span> remains a minimum <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> cut in the new flow network.</p></li>
</ol>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Solution</em></p>
<ol>
<li><p>True.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is in some minimum cut, then decreasing the capacity of <span class="math notranslate nohighlight">\(e\)</span> decreases the min cut value by 1.</p></li>
<li><p>Else, <span class="math notranslate nohighlight">\(e\)</span> is not in every min cut, then decreasing the capacity of <span class="math notranslate nohighlight">\(e\)</span> by 1 leaves the min cut value unchanged. Either way, the capacity decreases by at most 1. The claim follows from the max-flow-min-cut theorem.</p></li>
</ul>
<p>Algorithm to update the flow:</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(c(e) \ge f(e) + 1\)</span>, then the max flow remains the same.</p></li>
<li><p>Else <span class="math notranslate nohighlight">\(c(e) = f(e)\)</span> (saturated edge), then to satisfy the constraint, we need to remove one unit of flow from <span class="math notranslate nohighlight">\(s\)</span> to <span class="math notranslate nohighlight">\(t\)</span> that goes through edge <span class="math notranslate nohighlight">\(e\)</span>. The algorithm is</p>
<ul>
<li><p>Find a path <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(u\)</span> and a path <span class="math notranslate nohighlight">\(v\)</span>-<span class="math notranslate nohighlight">\(t\)</span> that contain only edges of positive flow. Remove <span class="math notranslate nohighlight">\(1\)</span> unit of flow for each edge on path <span class="math notranslate nohighlight">\(s-u\)</span>, and <span class="math notranslate nohighlight">\(v-t\)</span>. This step takes <span class="math notranslate nohighlight">\(O(m)\)</span>.</p></li>
<li><p>Run Ford-Fulkerson. There is at most one iteration since the flow will increases by at most <span class="math notranslate nohighlight">\(1\)</span>. One iteration takes <span class="math notranslate nohighlight">\(O(m)\)</span>.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>True.
Decreasing by <span class="math notranslate nohighlight">\(k\)</span> is the same as decreasing in <span class="math notranslate nohighlight">\(k\)</span> steps of 1. Each such step decreases the max flow by at most 1. So the total decrease is at most <span class="math notranslate nohighlight">\(k\)</span>.</p></li>
<li><p>True.</p>
<ul class="simple">
<li><p>If edge <span class="math notranslate nohighlight">\(e\)</span> is in every min cut, then increasing the capacity of <span class="math notranslate nohighlight">\(e\)</span> by <span class="math notranslate nohighlight">\(1\)</span> increases the min cut value by <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
<li><p>Else, edge <span class="math notranslate nohighlight">\(e\)</span> is not in every min cut, then increasing the capacity of <span class="math notranslate nohighlight">\(e\)</span> by <span class="math notranslate nohighlight">\(1\)</span> leaves the min cut value unchanged.</p></li>
</ul>
</li>
<li><p>True. Increasing by <span class="math notranslate nohighlight">\(k\)</span> is the same as increasing in <span class="math notranslate nohighlight">\(k\)</span> steps of 1. By the previous solution, each such step increases the max flow by at most <span class="math notranslate nohighlight">\(1\)</span>. So the total increase is at most <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>Algorithm to update the flow</p>
<ul class="simple">
<li><p>Repeat at most <span class="math notranslate nohighlight">\(k\)</span> times:</p>
<ul>
<li><p>Look for an augmenting path in the residual network by BFS/DFS.</p></li>
<li><p>If there is one, then update the existing flow, else terminate.</p></li>
</ul>
</li>
</ul>
<p>Each pass takes <span class="math notranslate nohighlight">\(O(m)\)</span>, total <span class="math notranslate nohighlight">\(O(km)\)</span>.</p>
</li>
<li><p>False. More specifically,</p>
<ul class="simple">
<li><p>If some edge has different capacity, increasing capacity might have resulted in different minimum cut, as the graph below.</p></li>
<li><p>Else all edges have same capacity then minimum cut would remain same. To see this, if all edges have the same capacity <span class="math notranslate nohighlight">\(c\)</span>, then the capacity of any cut is <span class="math notranslate nohighlight">\(xc\)</span> where <span class="math notranslate nohighlight">\(x\)</span> is the number of edges cut. So a min-cut has <span class="math notranslate nohighlight">\(x_\min\)</span>. After <span class="math notranslate nohighlight">\(c\)</span> becomes <span class="math notranslate nohighlight">\(c+1\)</span>, it is still a min-cut since it has <span class="math notranslate nohighlight">\(x_\min\)</span>.</p></li>
</ul>
<div class="figure align-default" id="max-flow-ex-1">
<a class="reference internal image-reference" href="../_images/max-flow-ex-1.png"><img alt="" src="../_images/max-flow-ex-1.png" style="width: 30%;" /></a>
<p class="caption"><span class="caption-number">Fig. 29 </span><span class="caption-text">New min-cut becomes <span class="math notranslate nohighlight">\(S\)</span>-<span class="math notranslate nohighlight">\(A\)</span> with cut capacity <span class="math notranslate nohighlight">\(5\)</span>.</span><a class="headerlink" href="#max-flow-ex-1" title="Permalink to this image">¶</a></p>
</div>
</li>
</ol>
</div>
</li>
<li><p>[<strong>Edges in residual graph</strong>] Suppose we are given a flow network <span class="math notranslate nohighlight">\(G\)</span>, and a valid flow <span class="math notranslate nohighlight">\(f\)</span> in that network. Let <span class="math notranslate nohighlight">\(G_f\)</span> be the corresponding residual graph, <span class="math notranslate nohighlight">\(P\)</span> a shortest <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> path in <span class="math notranslate nohighlight">\(G_f\)</span>, and <span class="math notranslate nohighlight">\(f ^\prime\)</span> a new flow obtained from <span class="math notranslate nohighlight">\(f\)</span> after performing a single iteration of the Ford-Fulkerson algorithm, with <span class="math notranslate nohighlight">\(P\)</span> as the augmenting path. Prove each one of the following statements.</p>
<ol class="simple">
<li><p>If <span class="math notranslate nohighlight">\(e \in G_f\)</span> but <span class="math notranslate nohighlight">\(e \notin G _{f ^\prime}\)</span>, then <span class="math notranslate nohighlight">\(e\in P\)</span>.</p></li>
<li><p>At least one edge of <span class="math notranslate nohighlight">\(P\)</span> does not belong to <span class="math notranslate nohighlight">\(G_{f ^\prime}\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(e=(u,v) \in G_{f ^\prime }\)</span> but <span class="math notranslate nohighlight">\(e \notin G_f\)</span>, then edge <span class="math notranslate nohighlight">\((v,u)\)</span> belongs to path <span class="math notranslate nohighlight">\(P\)</span>.</p></li>
</ol>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Solution</em></p>
<ol class="simple">
<li><ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is a forward edge in <span class="math notranslate nohighlight">\(G_f\)</span>, it disappears in <span class="math notranslate nohighlight">\(G_{f ^\prime }\)</span> iff we increase the flow <span class="math notranslate nohighlight">\(f(e) &lt; c(e)\)</span> to <span class="math notranslate nohighlight">\(c(e)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, such that in <span class="math notranslate nohighlight">\(G_{f ^\prime }: c_{f ^\prime }(e) = c(e)-f(e) = 0\)</span> and hence <span class="math notranslate nohighlight">\(e\)</span> disappears. According to the algorithm, if we increases <span class="math notranslate nohighlight">\(f(e)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, then <span class="math notranslate nohighlight">\(e\in P\)</span> in that iteration.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is a backward edge in <span class="math notranslate nohighlight">\(G_f\)</span>, it disappears in <span class="math notranslate nohighlight">\(G_{f ^\prime }\)</span> iff we decrease the flow <span class="math notranslate nohighlight">\(f(e ^\prime)&gt;0\)</span> to 0, such that in <span class="math notranslate nohighlight">\(G_{f ^\prime }: c_{f ^\prime }(e) = f(e) = 0\)</span> and hence <span class="math notranslate nohighlight">\(e\)</span> disappears. According to the algorithm, if we decrease <span class="math notranslate nohighlight">\(f(e ^\prime )\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, then <span class="math notranslate nohighlight">\(e\in P\)</span> in that iteration.</p></li>
</ul>
</li>
<li><p>Since we increase of decrease <span class="math notranslate nohighlight">\(\Delta = \min _{e \in E(P)}\left\{c_{f}(e)\right\}\)</span> for all corresponding edges in <span class="math notranslate nohighlight">\(G\)</span>, one edge’s flow <span class="math notranslate nohighlight">\(f(e)\)</span> must be increased to <span class="math notranslate nohighlight">\(c(e)\)</span> or decreased to <span class="math notranslate nohighlight">\(0\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(f(e)\)</span> is increased to <span class="math notranslate nohighlight">\(c(e)\)</span>, then the forward edge <span class="math notranslate nohighlight">\(e\)</span> disappears in <span class="math notranslate nohighlight">\(G_{f ^\prime }\)</span> since <span class="math notranslate nohighlight">\(c_{f ^\prime } (e) = c(e) - f(e)\)</span> changes from positive to <span class="math notranslate nohighlight">\(0\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f(e)\)</span> is decreased to <span class="math notranslate nohighlight">\(0\)</span>, then the backward edge <span class="math notranslate nohighlight">\(e ^\prime\)</span> disappears in <span class="math notranslate nohighlight">\(G_{f ^\prime }\)</span> since <span class="math notranslate nohighlight">\(c_{f ^\prime } (e ^\prime ) = f(e)\)</span> changes from positive to <span class="math notranslate nohighlight">\(0\)</span>.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is a forward edge, then we must decrease <span class="math notranslate nohighlight">\(f(e)\)</span> from <span class="math notranslate nohighlight">\(c(e)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>. According to the algorithm, if we decrease <span class="math notranslate nohighlight">\(f(e)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, then the backward edge <span class="math notranslate nohighlight">\(e ^\prime  = (v,u)\in P\)</span> in that iteration.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is a backward edge, then we must increase <span class="math notranslate nohighlight">\(f(e ^\prime)\)</span> from <span class="math notranslate nohighlight">\(0\)</span> in <span class="math notranslate nohighlight">\(G\)</span>. According to the algorithm, if we increase <span class="math notranslate nohighlight">\(f(e ^\prime)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, then the forward edge <span class="math notranslate nohighlight">\(e ^\prime  = (v,u)\in P\)</span> in that iteration.</p></li>
</ul>
</li>
</ol>
</div>
</li>
<li><p>T/F: If <span class="math notranslate nohighlight">\(f\)</span> is a valid <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> flow in graph <span class="math notranslate nohighlight">\(G\)</span> of value <span class="math notranslate nohighlight">\(v_f\)</span>, and <span class="math notranslate nohighlight">\(f ^\prime\)</span> is a valid <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> flow in the residual graph <span class="math notranslate nohighlight">\(G_f\)</span> of value <span class="math notranslate nohighlight">\(v(f ^\prime)\)</span>, then there is a valid <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> flow in graph G of value <span class="math notranslate nohighlight">\(v(f) + v(f ^\prime)\)</span>.</p>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Solution</em></p>
<p>True. Moreover, let <span class="math notranslate nohighlight">\(v (f_\max)\)</span> be the value of a max-flow in <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(v (f ^\prime _\max)\)</span> be the value of a max-flow in residual graph <span class="math notranslate nohighlight">\(G_f\)</span>, then we have <span class="math notranslate nohighlight">\(v(f) + v(f ^\prime) \le v (f_\max)\)</span> with equality iff <span class="math notranslate nohighlight">\(v(f ^\prime) = v(f ^\prime _\max)\)</span>.</p>
</div>
</li>
<li><p>[<strong>Acyclic flow</strong>] Show an efficient algorithm to find a maximum <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> flow in <span class="math notranslate nohighlight">\(G\)</span> which is integral and acyclic.</p>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Solution</em></p>
<p>Algorithm (Eliminating flow cycles)</p>
<ol class="simple">
<li><p>Use Edmonds-Karp algorithm to compute a maximum flow <span class="math notranslate nohighlight">\(f\)</span></p></li>
<li><p>Delete every edge <span class="math notranslate nohighlight">\(e\)</span> with <span class="math notranslate nohighlight">\(f(e)=0\)</span> in <span class="math notranslate nohighlight">\(G\)</span> and obtain a new flow network <span class="math notranslate nohighlight">\(H\)</span>.</p></li>
<li><p>While True:</p>
<ul class="simple">
<li><p>Find a simple cycle <span class="math notranslate nohighlight">\(C\)</span> in <span class="math notranslate nohighlight">\(H\)</span>, or correctly establishes that no such cycle exists. To to so, for each vertex <span class="math notranslate nohighlight">\(v \in V(H)\)</span>, perform BFS from <span class="math notranslate nohighlight">\(v\)</span>. If BFS ever discovers a vertex <span class="math notranslate nohighlight">\(u\)</span>, such that an edge <span class="math notranslate nohighlight">\((u,v)\in E(H)\)</span>, then we can use the BFS to compute a simple path connecting <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(u\)</span> in <span class="math notranslate nohighlight">\(H\)</span>, which, together with edge <span class="math notranslate nohighlight">\((u,v)\)</span> provides a simple cycle in <span class="math notranslate nohighlight">\(C\)</span> containing <span class="math notranslate nohighlight">\(v\)</span>.</p>
<ul>
<li><p>If the BFS never discovers a vertex <span class="math notranslate nohighlight">\(u\)</span> for which edge <span class="math notranslate nohighlight">\((u,v)\)</span> exists, then no simple cycle in <span class="math notranslate nohighlight">\(H\)</span> may contain <span class="math notranslate nohighlight">\(v\)</span>. Terminate.</p></li>
</ul>
</li>
<li><p>Otherwise, <span class="math notranslate nohighlight">\(C\)</span> exists. Select an edge <span class="math notranslate nohighlight">\(e\in E(C)\)</span> that carries the smallest amount of flow among all edges in <span class="math notranslate nohighlight">\(C\)</span>; denote this flow amount by <span class="math notranslate nohighlight">\(\Delta\)</span>. We then decrease the flow on every edge of <span class="math notranslate nohighlight">\(C\)</span> by <span class="math notranslate nohighlight">\(\Delta\)</span>, and recompute <span class="math notranslate nohighlight">\(H\)</span>. This is guaranteed to produce a feasible flow, whose value is exactly the same as the value of the original flow (since vertex <span class="math notranslate nohighlight">\(s\)</span> may not lie on cycle <span class="math notranslate nohighlight">\(C\)</span>).</p></li>
</ul>
</li>
</ol>
<p>Running Time <span class="math notranslate nohighlight">\(O(m^2 n)\)</span></p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(O(m^2 n)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(O(m)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(O(m\cdot mn)\)</span></p>
<ul class="simple">
<li><p>In every iteration of the algorithm, the flow on at least one edge decreases to <span class="math notranslate nohighlight">\(0\)</span>, and we never increase the flow on any edge. Therefore, the total number of iterations is <span class="math notranslate nohighlight">\(O(m)\)</span>.</p></li>
<li><p>Finding a simple cycle takes <span class="math notranslate nohighlight">\(O(n\cdot m)\)</span></p></li>
<li><p>Updating flow and recomputing graph <span class="math notranslate nohighlight">\(H\)</span> takes <span class="math notranslate nohighlight">\(O(m)\)</span></p></li>
</ul>
</li>
</ol>
</div>
</li>
<li><p>[<strong>Incoming edges to source and outgoing edge from sink</strong>] Assume now that vertex <span class="math notranslate nohighlight">\(s\)</span> may have incoming edges and <span class="math notranslate nohighlight">\(t\)</span> may have outgoing edges. Recall that in such a case, the value of a flow <span class="math notranslate nohighlight">\(f\)</span> is dened to be <span class="math notranslate nohighlight">\(\sum_{e \in \delta^{+}(s)} f(e)-\sum_{e \in \delta^{-}(s)} f(e)\)</span>. Prove that there exists a maximum flow <span class="math notranslate nohighlight">\(f\)</span>, such that <span class="math notranslate nohighlight">\(f(e)=0\)</span> for every edge <span class="math notranslate nohighlight">\(e \in \delta^{-}(s) \cup \delta^{+}(t)\)</span>.</p>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Solution</em></p>
<p>First, we run Edmonds-Karp algorithm to obtain a maximum <span class="math notranslate nohighlight">\(s\)</span>-<span class="math notranslate nohighlight">\(t\)</span> flow <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>In <span class="math notranslate nohighlight">\(f\)</span>, if there is an edge <span class="math notranslate nohighlight">\(e \in \delta^- (s)\)</span> such that <span class="math notranslate nohighlight">\(f(e)&gt;0\)</span>, then <span class="math notranslate nohighlight">\(s\)</span> must be in a cycle that every edge contains positive flow (why??). For each of such cycle <span class="math notranslate nohighlight">\(C\)</span>, we subtract <span class="math notranslate nohighlight">\(\Delta = \min _{e \in C} f(e)\)</span> from all flows of edges in <span class="math notranslate nohighlight">\(C\)</span> to eliminate it. At most <span class="math notranslate nohighlight">\(m\)</span> iterations, we will have <span class="math notranslate nohighlight">\(f(e)=0\)</span> for all <span class="math notranslate nohighlight">\(e \in \delta^- (s)\)</span>. Note that by the flow conservation constraints, the resulting flow is also a maximum flow and the flow value is unchanged.</p>
<p>The operation to the outgoing edges from <span class="math notranslate nohighlight">\(t\)</span> is similar. Finally, we obtain a required maximum flow.</p>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
<p>An alternative approach is to prove the output graph in the previous question has no positive flow for edges entering <span class="math notranslate nohighlight">\(s\)</span> and leaving <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>Note that this proves that in the maximum flow problem, we can assume without loss of generality that no edge enters s and no edge leaves t, as deleting all such edges does not change the maximum flow value.</p>
</div>
</li>
</ol>
<div class="section" id="more">
<h3>More<a class="headerlink" href="#more" title="Permalink to this headline">¶</a></h3>
<p>http://www.cim.mcgill.ca/~langer/251/E11-networkflow-2.pdf</p>
<p>http://web.stanford.edu/class/archive/cs/cs161/cs161.1176/maxflow_problems.pdf</p>
<p>https://courses.engr.illinois.edu/cs573/fa2012/hw/files/hw_3_pract.pdf</p>
<p>https://www.cs.cornell.edu/courses/cs6820/2016fa/handouts/flows.pdf</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./25-graph-related"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="21-minimum-spanning-tree.html" title="previous page">Minimum Spanning Tree</a>
    <a class='right-next' id="next-link" href="32-matching.html" title="next page">Matching</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Dennis Zheng<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
    
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>


    
    <!-- Google Analytics -->
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-150740237-2', 'auto');
      ga('set', 'anonymizeIp', true);
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
    <!-- End Google Analytics -->
    
  </body>
</html>