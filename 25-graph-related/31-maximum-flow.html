
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maximum Flow &#8212; Data Science Handbook</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.c441f2ba0852f4cabcb80105e3a46ae6.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Matching" href="32-matching.html" />
    <link rel="prev" title="Minimum Spanning Tree" href="21-minimum-spanning-tree.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  
  <h1 class="site-logo" id="site-title">Data Science Handbook</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../index.html">
   Data Science Handbook
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Foundations
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../11-math/00-math.html">
   Math
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/11-combinatorics.html">
     Combinatorics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/12-derangement.html">
     Derangement
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/20-fields-and-vector-spaces.html">
     Fields and Vector Spaces
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/21-linear-algebra.html">
     Linear Algebra
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/51-linear-programming.html">
     Linear Programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/61-graphs.html">
     Graphs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11-math/90-puzzles.html">
     Puzzles
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../12-probabilities/00-probabilities.html">
   Probabilities
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/11-expectation-and-variance.html">
     Expectation and Variance
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/13-correlation-and-dependence.html">
     Correlation and Dependence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/31-bayesian-theorem.html">
     Bayesian’s Theorem
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/51-markov-chain.html">
     Markov Chain
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/71-sampling.html">
     Sampling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/90-multivariate-notations.html">
     Multivariate Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12-probabilities/91-large-sample-theory.html">
     Large Sample Theory
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../13-statistics/00-statistics.html">
   Statistics
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/11-sample-survey.html">
     Sample Survey
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/13-randomized-trial.html">
     Causality and Randomized Trial
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/21-hypothesis-testing.html">
     Hypothesis Testing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/25-two-sample-tests.html">
     Two Sample Mean Tests
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/33-confusion-matrix.html">
     Confusion Matrix
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/41-maximum-likelihood-estimation.html">
     Maximum Likelihood Estimator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13-statistics/43-estimators-evaluation.html">
     Estimators Evaluation
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../14-python/00-python.html">
   Python
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../14-python/11-programming-tools.html">
     Programmer tools
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../14-python/12-syntax.html">
     Syntax
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../14-python/13-data-structure.html">
     Data Structures
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../14-python/15-functional-programming.html">
     Functional Programming
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../17-sql/00-sql.html">
   SQL
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../17-sql/11-database.html">
     Database
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../17-sql/12-relational-structure.html">
     Relational Structure
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../17-sql/31-data-query.html">
     Data Query
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../17-sql/33-data-manipulation.html">
     Data Manipulation
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../19-miscellaneous/00-miscellaneous.html">
   Miscellaneous
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../19-miscellaneous/11-latex.html">
     LaTeX
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../19-miscellaneous/13-myst.html">
     MyST Markdown
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Algorithms
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../20-algorithms-concepts/00-algorithms-concepts.html">
   Algorithms Concepts
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../20-algorithms-concepts/51-polynomial-reduction.html">
     Polynomial Reduction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../20-algorithms-concepts/53-P-and-NP.html">
     <span class="math notranslate nohighlight">
      \(P\)
     </span>
     and
     <span class="math notranslate nohighlight">
      \(NP\)
     </span>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../20-algorithms-concepts/61-randomized-algo.html">
     Randomized Algorithms
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../21-greedy-algorithms/00-greedy-algorithms.html">
   Greedy Algorithms
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../21-greedy-algorithms/11-interval-scheduling.html">
     Interval Scheduling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../21-greedy-algorithms/31-huffman-coding.html">
     Huffman Coding
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../23-dynamic-programming/00-dynamic-programming.html">
   Dynamic Programming
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/11-weighted-interval-scheduling.html">
     Weighted Interval Scheduling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/13-longest-common-subsequence.html">
     Longest Common Subsequence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/15-longest-increasing-subsequence.html">
     Longest Increasing Subsequence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/17-largest-sum-subsequence.html">
     Largest Sum Subsequence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/31-knapsack.html">
     Minimum Knapsack
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../23-dynamic-programming/51-chain-matrix-multiplication.html">
     Chain Matrix Multiplication
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="00-graph-related.html">
   Graph Related
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="13-shortest-path.html">
     Shortest Path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="21-minimum-spanning-tree.html">
     Minimum Spanning Tree
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Maximum Flow
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="32-matching.html">
     Matching
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="42-maximum-independent-set.html">
     Maximum Independent Set in Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="91-LP-max-flow-min-cut.html">
     LP on Max-flow and Min-cut
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Machine Learning
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../30-ml-basics/00-ml-basics.html">
   Machine Learning Basics
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/02-taxonomy.html">
     Taxonomy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/03-information-theory.html">
     Information Theory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/05-kernels.html">
     Kernels
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/11-missing-values.html">
     Missing Values
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/51-semi-supervised.html">
     Semi-supervised Learning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/53-self-supervised.html">
     Self-supervised Learning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../30-ml-basics/61-fourier-transform.html">
     Fourier Transform-based Representations
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../31-regression/00-regression.html">
   Regression
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/11-lm-estimation.html">
     Linear Models - Estimation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/12-lm-inference.html">
     Linear Models - Inference
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/13-lm-diagnosis.html">
     Linear Models - Diagnosis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/14-lm-advanced.html">
     Linear Models - Advanced Topics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/21-generalized-linear-models.html">
     Generalized Linear Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/22-logistic-regression.html">
     Logistic Regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/23-multinomial-logitsitc.html">
     Multinomial Logistic Regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/24-ordinal-logistic.html">
     Ordinal Logistic Regression
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../31-regression/25-poisson-regression.html">
     Poisson Regression
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../32-classification/00-classification.html">
   Classification
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../32-classification/11-support-vector-machine.html">
     Support Vector Machine
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../32-classification/21-decision-tree.html">
     Decision Tree
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../33-dimensionality-reduction/00-dimensionality-reduction.html">
   Dimensionality Reduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/11-principal-component-analysis.html">
     Principal Component Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/13-canonical-correlation-analysis.html">
     Canonical Corerlation Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/21-multidimensional-scaling.html">
     Multidimensional Scaling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/23-graph-based-spectral-methods.html">
     Graph-based Spectral Methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/25-t-SNE.html">
     SNE and
     <span class="math notranslate nohighlight">
      \(t\)
     </span>
     -SNE
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/31-kernel-pca.html">
     Kernel PCA
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../33-dimensionality-reduction/32-kernel-cca.html">
     Kernel CCA
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../34-clustering/00-clustering.html">
   Clustering
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../34-clustering/11-k-means.html">
     <span class="math notranslate nohighlight">
      \(k\)
     </span>
     -means clustering
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../34-clustering/13-agglomerative-methods.html">
     Agglomerative Methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../34-clustering/31-spectral-clustering.html">
     Spectral Clustering
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../34-clustering/41-gaussian-mixtures.html">
     Gaussian Mixtures
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../35-graphical-models/00-graphical-models.html">
   Graphical Models
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../35-graphical-models/11-hidden-markov-models.html">
     Hidden Markov Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../35-graphical-models/31-topic-models.html">
     Topic Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../35-graphical-models/33-language-models.html">
     Language Models
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../37-neural-networks/00-neural-networks.html">
   Neural Networks
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/01-stochastic-gradient-descent.html">
     Stochastic Gradient Descent
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/03-trainability.html">
     Trainability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/05-regularization.html">
     Regularization
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/11-autoencoders.html">
     Autoencoders
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/13-variational-autoencoders.html">
     Variational Autoencoders
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/31-sequential-models.html">
     Sequential Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../37-neural-networks/41-GAN.html">
     Generative Adversarial Networks
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../38-ml-for-graph-data/00-ml-for-graph-data.html">
   Machine Learning for Graph Data
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/25-graph-related/31-maximum-flow.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/dennissxz/data-science-handbook"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/dennissxz/data-science-handbook/issues/new?title=Issue%20on%20page%20%2F25-graph-related/31-maximum-flow.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                    title="Fullscreen mode"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i>
            Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#problem">
   Problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#analysis">
   Analysis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algorithm">
   Algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#correctness">
   Correctness
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#feasibility">
     Feasibility
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optimality">
     Optimality
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#minimum-cut">
   Minimum Cut
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     Problem
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id2">
     Analysis
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexity">
   Complexity
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#improvement-and-extension">
   Improvement and Extension
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#edmonds-korp-algorithm">
     Edmonds-Korp Algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#approximation">
     Approximation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#other-properties">
     Other Properties
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#flow-path-perspective">
     Flow-path Perspective
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#undirected-graphs">
     Undirected Graphs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#edge-disjoint-paths-and-s-t-cut">
     Edge-Disjoint Paths and
     <span class="math notranslate nohighlight">
      \(S-T\)
     </span>
     Cut
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#vertex-capacity-max-flow">
     Vertex-capacity Max Flow
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#applications">
   Applications
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#image-segmentation">
     Image Segmentation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercise">
   Exercise
  </a>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="maximum-flow">
<h1>Maximum Flow<a class="headerlink" href="#maximum-flow" title="Permalink to this headline">¶</a></h1>
<p>Widely used in algorithms on graphs.</p>
<div class="section" id="problem">
<h2>Problem<a class="headerlink" href="#problem" title="Permalink to this headline">¶</a></h2>
<p>Send something from a place to another over some networks, e.g. information, package, oil.</p>
<p>Each edge has capacity limit.</p>
<dl class="simple myst">
<dt>Input</dt><dd><p>directed graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>, capacities <span class="math notranslate nohighlight">\(c(e)\ge 0\)</span>, source vertex <span class="math notranslate nohighlight">\(s\in V\)</span>, destination vertex <span class="math notranslate nohighlight">\(t \in V\)</span>.</p>
</dd>
<dt>Goal</dt><dd><p>find the maximum volume flowing from <span class="math notranslate nohighlight">\(s\)</span> to <span class="math notranslate nohighlight">\(t\)</span> subject to the capacity constraint.</p>
</dd>
</dl>
</div>
<div class="section" id="analysis">
<h2>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h2>
<p>Assume</p>
<ul class="simple">
<li><p>all capacities are integers (capacity is a finite number. if not integer, scale.)</p></li>
<li><p>no edges enter <span class="math notranslate nohighlight">\(s\)</span> or leave <span class="math notranslate nohighlight">\(t\)</span> (makes no sense to use those edges)</p></li>
<li><p>call all edges entering <span class="math notranslate nohighlight">\(v\)</span> by <span class="math notranslate nohighlight">\(\delta ^- (v)\)</span></p></li>
<li><p>call all edges leaving <span class="math notranslate nohighlight">\(v\)</span> by <span class="math notranslate nohighlight">\(\delta ^+ (v)\)</span></p></li>
</ul>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>If the two vertices of an edge are <span class="math notranslate nohighlight">\(e=(u,v)\)</span>, sometimes we write <span class="math notranslate nohighlight">\(f(u,v)\)</span> for convenience. If there is no edge between two vertices <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>, then <span class="math notranslate nohighlight">\(f(u,v)=0\)</span>.</p>
</div>
<dl class="simple myst">
<dt>Definition (Flow)</dt><dd><p>A function <span class="math notranslate nohighlight">\(f:E \rightarrow \mathbb{R}\)</span> which assign a value <span class="math notranslate nohighlight">\(f(e)\)</span> to every edge <span class="math notranslate nohighlight">\(e \in E\)</span>, subject to</p>
</dd>
</dl>
<ul>
<li><p>capacity constraints: edge flow less than edge capacity</p>
<div class="math notranslate nohighlight">
\[\forall e: \quad 0\le f(e) \le c(e)\]</div>
</li>
<li><p>flow conservation constraint: in-flow = out-flow for all intermediate nodes.</p>
<div class="math notranslate nohighlight">
\[\forall v \in V \backslash \left\{ s,t \right\}: \quad \sum_ {e\in \delta^- (v)} f(e) = \sum_ {e\in \delta^+ (v)} f(e) \quad\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[f^{\text{in}}(v) = f^{\text{out}}(v)\]</div>
</li>
</ul>
<dl class="simple myst">
<dt>Definition (Value of flow)</dt><dd><p>The value of a flow is the amount of out-flow from source node <span class="math notranslate nohighlight">\(s\)</span> (assuming no in-flow to <span class="math notranslate nohighlight">\(s\)</span>).</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{val}(f) = f^{\text{out}}(s) = \sum_ {e\in \delta^+ (s)} f(e)
  \]</div>
</dd>
<dt>Observation (Flow cancelation operation on anti-parallel edges)</dt><dd><p>For two anti-parallel edges <span class="math notranslate nohighlight">\(e = (u,v)\)</span> and <span class="math notranslate nohighlight">\(e ^\prime  = (v,u)\)</span>. Suppose <span class="math notranslate nohighlight">\(f(e), f(e ^\prime ) &gt;0\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\Delta = \min \left\{ f(e), f(e ^\prime ) \right\}\)</span> and assign new flow</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  f ^\prime (e) = f(e) - \Delta \\
  f ^\prime (e ^\prime ) = f(e ^\prime ) - \Delta
  \end{split}\]</div>
<p>Then the new flow <span class="math notranslate nohighlight">\(f ^\prime\)</span> is still a feasible flow with the same value of flow <span class="math notranslate nohighlight">\(f\)</span>.</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{val}(f ^\prime ) = \operatorname{val}(f)
  \]</div>
</dd>
</dl>
<div class="dropdown note admonition">
<p class="admonition-title"> Greedy algorithms not optimal</p>
<p>Given a simple <span class="math notranslate nohighlight">\(s-t\)</span> path <span class="math notranslate nohighlight">\(P\)</span> and a flow <span class="math notranslate nohighlight">\(f\)</span>, how much available capacity left?</p>
<div class="math notranslate nohighlight">
\[
\Delta(P) = \min _{e \in E(P)} \left\{ c(e) - f(e) \right\}
\]</div>
<ul class="simple">
<li><p>Start: <span class="math notranslate nohighlight">\(\forall e \in E, f(e) = 0\)</span></p></li>
<li><p>While there is a simple <span class="math notranslate nohighlight">\(s-t\)</span> path <span class="math notranslate nohighlight">\(P\)</span> with <span class="math notranslate nohighlight">\(\Delta(P)&gt;0\)</span>, set for every <span class="math notranslate nohighlight">\(e \in E(P)\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
f(e)\leftarrow f(e) + \Delta(p)
\]</div>
<p>This gives a feasible solution. Optimal? No, depends on the order of <span class="math notranslate nohighlight">\(s-t\)</span> path in <code class="docutils literal notranslate"><span class="pre">WHILE</span></code>.</p>
</div>
</div>
<div class="section" id="algorithm">
<h2>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h2>
<p>We first make an additional assumption and define residual flow networks.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>This assumption is not necessary for the algorithm to run, but make the algorithm easier to understand.</p>
</div>
<dl class="simple myst">
<dt>Assumption (No anti-parallel edges)</dt><dd><p>Input <span class="math notranslate nohighlight">\(G\)</span> has no anti-parallel edges. If there is, say <span class="math notranslate nohighlight">\(e = (u,v)\)</span> and <span class="math notranslate nohighlight">\(e ^\prime  = (v,u)\)</span>, then add a node <span class="math notranslate nohighlight">\(x\)</span> in-between <span class="math notranslate nohighlight">\(e = (u,v)\)</span> and the new edges have the same capacity <span class="math notranslate nohighlight">\(c(u,x) = c(x,v) = c(u,v)\)</span>.</p>
</dd>
<dt>Definition (Residual Flow Network)</dt><dd><p>Given a graph <span class="math notranslate nohighlight">\(G\)</span> and a feasible flow <span class="math notranslate nohighlight">\(f\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, let <span class="math notranslate nohighlight">\(G_f\)</span> be a new graph with the same vertices but new edges.</p>
</dd>
</dl>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>One can check if the residual capacity assigned to a pair of forward edge and backward edge in the residual flow network are correct by checking their sum of residual capacity <span class="math notranslate nohighlight">\(c_f(e) + c_f(e ^\prime)\)</span>, which should be <span class="math notranslate nohighlight">\(c(e)\)</span>.</p>
</div>
<ul>
<li><p>For every <span class="math notranslate nohighlight">\(e(u,v) \in G\)</span>, add edges and assign capacity (called <strong>residual capacity</strong>)</p>
<ul>
<li><p>add a forward edge to reflect <strong>unused</strong> capacity of <span class="math notranslate nohighlight">\(e\)</span></p>
<div class="math notranslate nohighlight">
\[
        c_f (u,v) = c(e) - f(e)
        \]</div>
</li>
<li><p>add a backward edge <span class="math notranslate nohighlight">\((v,u)\)</span> to reflect <strong>used</strong> capacity</p>
<div class="math notranslate nohighlight">
\[
        c_f (v,u) = f(e)
        \]</div>
</li>
</ul>
</li>
<li><p>For every edge <span class="math notranslate nohighlight">\(e ^\prime\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span> with zero residual capacity <span class="math notranslate nohighlight">\(c_f (e ^\prime ) = 0\)</span>, delete.</p></li>
</ul>
<div class="figure align-default" id="max-flow-three-edges">
<a class="reference internal image-reference" href="../_images/max-flow-three-edges.png"><img alt="" src="../_images/max-flow-three-edges.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 15 </span><span class="caption-text">Three kinds of edge in <span class="math notranslate nohighlight">\(G\)</span> [Chuzhoy 2021]</span><a class="headerlink" href="#max-flow-three-edges" title="Permalink to this image">¶</a></p>
</div>
<p>Ford-Fulkerson algorithm is an iterative algorithm. In each iteration, we compute the residual floe network of the current graph and use that to improve the original graph. Note that flow <span class="math notranslate nohighlight">\(f()\)</span> only exists in the original graph.</p>
<hr class="docutils" />
<p><strong>Ford-Fulkerson’s algorithm</strong></p>
<hr class="docutils" />
<ul>
<li><p>Start:</p>
<ul>
<li><p>For all edge <span class="math notranslate nohighlight">\(e \in E(G)\)</span>, initialize zero flow <span class="math notranslate nohighlight">\(f(e)=0\)</span>.</p></li>
<li><p>Compute the residual flow network <span class="math notranslate nohighlight">\(G_f\)</span>. For every <span class="math notranslate nohighlight">\(e(u,v) \in G\)</span>, add edges and assign capacity (called <strong>residual capacity</strong>)</p>
<ul>
<li><p>add a forward edge to reflect <strong>unused</strong> capacity of <span class="math notranslate nohighlight">\(e\)</span></p>
<div class="math notranslate nohighlight">
\[
          c_f (u,v) = c(e) - f(e)
          \]</div>
</li>
<li><p>add a backward edge <span class="math notranslate nohighlight">\((v,u)\)</span> to reflect <strong>used</strong> capacity</p>
<div class="math notranslate nohighlight">
\[
          c_f (v,u) = f(e)
          \]</div>
</li>
<li><p>delete edges with zero residual capacity</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>An augmenting path in residual graph can be found using DFS or BFS.</p>
</div>
<ul>
<li><p>While <span class="math notranslate nohighlight">\(\exists\)</span> a simple path <span class="math notranslate nohighlight">\(s-t\)</span> path <span class="math notranslate nohighlight">\(P\)</span> in the residual flow network <span class="math notranslate nohighlight">\(G_f\)</span>, we “push” flow along this path (aka <em>augmenting path</em>).</p>
<ul>
<li><p>Compute the smallest residual capacity along that path</p>
<div class="math notranslate nohighlight">
\[\Delta \leftarrow \min _{e \in E(P)} \left\{ c_f(e) \right\}\]</div>
</li>
<li><p>For each edge <span class="math notranslate nohighlight">\(e=(u,v) \in P\)</span>, check whether it is a forward edge or a backward edge w.r.t. the original graph.</p>
<ul>
<li><p>If <span class="math notranslate nohighlight">\(e=(u,v)\)</span> is a forward edge, then <span class="math notranslate nohighlight">\((u,v) \in G\)</span>, and we <strong>increase</strong> the flow of that edge by <span class="math notranslate nohighlight">\(\Delta\)</span>,</p>
<div class="math notranslate nohighlight">
\[f(u,v)\leftarrow f(u,v) + \Delta\]</div>
</li>
<li><p>Else, <span class="math notranslate nohighlight">\(e=(u,v)\)</span> is a backward edge, then <span class="math notranslate nohighlight">\((v,u) \in G\)</span>, and we <strong>decrease</strong> the flow of <span class="math notranslate nohighlight">\((v,u)\)</span> by <span class="math notranslate nohighlight">\(\Delta\)</span>,</p>
<div class="math notranslate nohighlight">
\[f(v,u) \leftarrow f(v,u) - \Delta\]</div>
</li>
</ul>
</li>
<li><p>Re-compute <span class="math notranslate nohighlight">\(G_f\)</span>.</p></li>
</ul>
</li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="correctness">
<h2>Correctness<a class="headerlink" href="#correctness" title="Permalink to this headline">¶</a></h2>
<div class="section" id="feasibility">
<h3>Feasibility<a class="headerlink" href="#feasibility" title="Permalink to this headline">¶</a></h3>
<dl class="simple myst">
<dt>Claim (Stops in finit time)</dt><dd><p>The FF algorithm stops after at most <span class="math notranslate nohighlight">\(\sum_{v\in \operatorname{succ}(s)} c(s, v)\)</span> iterations.</p>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof</em></p>
<p>Upon initialization, <span class="math notranslate nohighlight">\(f(e)=0\)</span> are integers. In each iteration, in <span class="math notranslate nohighlight">\(G_f\)</span>, all residual capacities <span class="math notranslate nohighlight">\(c_f(e)\)</span> are integers and at least 1. The smallest residual capacity is also integer and at least 1. So the update flow of each edge in <span class="math notranslate nohighlight">\(G\)</span> is <span class="math notranslate nohighlight">\(f(e)\leftarrow f(e) \pm \Delta\)</span>.</p>
<p>Note that along the augmenting path <span class="math notranslate nohighlight">\(P\)</span>, the first edge out from <span class="math notranslate nohighlight">\(s\)</span> is always a forward edge (by assumption). As a result, the updated flow of that edge is <span class="math notranslate nohighlight">\(f(e) \mathrel{+}= \Delta\)</span>. Hence, the updated value of the flow is <span class="math notranslate nohighlight">\(\operatorname{val}(f) \mathrel{+}= \Delta\)</span>, which is at least 1.</p>
<p>Therefore, the algorithm stops after at most <span class="math notranslate nohighlight">\(\sum_{v\in \operatorname{succ}(s)} c(s, v)\)</span> iterations.</p>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
<dl class="simple myst">
<dt>Claim 2 (Always a valid flow)</dt><dd><p>Flow <span class="math notranslate nohighlight">\(f\)</span> always remains a valid flow. That is, the flow always satisfies the capacity constraints and the conservation constraints.</p>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof by induction</em></p>
<ul class="simple">
<li><p>Base: <span class="math notranslate nohighlight">\(\forall e: f(e)=0\)</span> at initialization is a valid flow</p></li>
<li><p>Step: if at the beginning of an iteration, <span class="math notranslate nohighlight">\(f\)</span> is valid, then after the iteration, it remains valid.</p></li>
</ul>
<p>We now prove the capacity constraints and the conservation of flow constraints.</p>
<p><strong>Capacity constraints</strong></p>
<p>For every edge <span class="math notranslate nohighlight">\(e=(u,v)\)</span> in the augmenting path <span class="math notranslate nohighlight">\(P\)</span>,</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is a forward edge, <span class="math notranslate nohighlight">\(e \in G\)</span>, then we increases <span class="math notranslate nohighlight">\(f(e) \mathrel{+}= \Delta\)</span>. By definition, <span class="math notranslate nohighlight">\(\Delta \le c_f (e) =  c(e) - f(e)\)</span>. Hence <span class="math notranslate nohighlight">\(f(e)+\Delta \le c(e)\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(e\)</span> is a backward edge, then <span class="math notranslate nohighlight">\(e ^\prime = (v,u)\in G\)</span>, we decrease <span class="math notranslate nohighlight">\(f(e ^\prime) \mathrel{-}= \Delta\)</span>. Will it be negative? No, since by definition, <span class="math notranslate nohighlight">\(\Delta \le c_f(e) = f(e ^\prime)\)</span>, so <span class="math notranslate nohighlight">\(f(e ^\prime) - \Delta \ge 0\)</span>.</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>Conservation of flow constraints</strong></p>
<p>By definition, we want to prove <span class="math notranslate nohighlight">\(\forall v \in V \backslash \left\{ s,t \right\}\)</span></p>
<div class="math notranslate nohighlight">
\[f^{\text{in}}(v) = f^{\text{out}}(v)\]</div>
<p>Suppose along <span class="math notranslate nohighlight">\(P\)</span> the two edges of <span class="math notranslate nohighlight">\(v\)</span> are <span class="math notranslate nohighlight">\(e_1, e_2\)</span></p>
<div class="math notranslate nohighlight">
\[ \text{along } P: \quad \ldots \overset{e_1}{\longrightarrow} v \overset{e_2}{\longrightarrow} \ldots\]</div>
<p>We have the following 3 possible situations for <span class="math notranslate nohighlight">\(e_1\)</span> and <span class="math notranslate nohighlight">\(e_2\)</span>,</p>
<ol>
<li><p>both forward edges, then we increase both <span class="math notranslate nohighlight">\(f(e_1)\)</span> and <span class="math notranslate nohighlight">\(f(e_2)\)</span> by <span class="math notranslate nohighlight">\(\Delta\)</span>, so the in- and out-flow of <span class="math notranslate nohighlight">\(v\)</span> both increases by <span class="math notranslate nohighlight">\(\Delta\)</span>.</p>
<div class="math notranslate nohighlight">
\[ \text{in } G: \quad \ldots \overset{e_1}{\longrightarrow} v \overset{e_2}{\longrightarrow} \ldots\]</div>
</li>
<li><p>both backward edges, then we decrease <span class="math notranslate nohighlight">\(f(e_1 ^\prime)\)</span> and <span class="math notranslate nohighlight">\(f(e_2 ^\prime)\)</span> by <span class="math notranslate nohighlight">\(\Delta\)</span>, so the in- and out-flow of <span class="math notranslate nohighlight">\(v\)</span> both decreases by <span class="math notranslate nohighlight">\(\Delta\)</span>.</p>
<div class="math notranslate nohighlight">
\[\text{in } G: \quad \ldots \overset{e_1 ^\prime }{\longleftarrow} v \overset{e_2 ^\prime }{\longleftarrow} \ldots\]</div>
</li>
<li><p><span class="math notranslate nohighlight">\(e_1\)</span> forward, <span class="math notranslate nohighlight">\(e_2\)</span> backward, then <span class="math notranslate nohighlight">\(f(e_1)\)</span> increases by <span class="math notranslate nohighlight">\(\Delta\)</span>, and <span class="math notranslate nohighlight">\(f(e_2 ^\prime)\)</span> decreases by <span class="math notranslate nohighlight">\(\Delta\)</span>, so the two changes to in-follow of <span class="math notranslate nohighlight">\(v\)</span> cancel out. No change to out-flow.</p>
<div class="math notranslate nohighlight">
\[\text{in } G: \quad \ldots \overset{e_1}{\longrightarrow} v \overset{e_2 ^\prime }{\longleftarrow} \ldots\]</div>
</li>
<li><p><span class="math notranslate nohighlight">\(e_2\)</span> forward, <span class="math notranslate nohighlight">\(e_1\)</span> backward, similar to the case 3.</p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
<p>Therefore, we show that after an iteration is completed, the constraints remain to be satisfied, so the feasibility is guaranteed.</p>
</div>
<div class="section" id="optimality">
<h3>Optimality<a class="headerlink" href="#optimality" title="Permalink to this headline">¶</a></h3>
<p>To prove optimality of the FF algorithm, we first introduce some definitions.</p>
<p>Recall the definition of in-flow to and out-flow from a node <span class="math notranslate nohighlight">\(v\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}
f^{\text{in}}(v) = \sum_{e \in \delta^{-}(v)} f(e) \\
f^{\text{out}}(v) =\sum_{e \in \delta^{+}(v)} f(e)
\end{split}\]</div>
<p>We define similar quantities for a set of vertices.</p>
<dl class="simple myst">
<dt>Definition (In- and out-flow of a set of vertices)</dt><dd><p>For a set of vertices <span class="math notranslate nohighlight">\(S \subseteq V\)</span>, ,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  f^{\text{in}}(S) = \sum_{u\notin S, v \in S} f(u, v) \\
  f^{\text{out}}(S) = \sum_{u\in S, v \notin S} f(u, v) \\
  \end{split}\]</div>
</dd>
<dt>Definition (<span class="math notranslate nohighlight">\(s-t\)</span> cut)</dt><dd><p>An <span class="math notranslate nohighlight">\(s-t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span> is a cut in <span class="math notranslate nohighlight">\(G\)</span> such that the source node <span class="math notranslate nohighlight">\(s\in A\)</span> and the destination node <span class="math notranslate nohighlight">\(t\in B\)</span>. The in- and out-flow of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> have the relations</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  f^{\text{in}}(A) = f^{\text{out}}(B) \\
  f^{\text{out}}(A) = f^{\text{in}}(B)
  \end{split}\]</div>
</dd>
<dt>Definition (Capacity of an <span class="math notranslate nohighlight">\(s-t\)</span> cut)</dt><dd><p>The capacity of an <span class="math notranslate nohighlight">\(s-t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span> is defined as the sum of capacities of the edges from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span></p>
<div class="math notranslate nohighlight">
\[
  c(A,B) = \sum _{u\in A, v \in B} c(u, v)
  \]</div>
</dd>
<dt>Property (Compute flow value from a cut)</dt><dd><p>Let <span class="math notranslate nohighlight">\(f\)</span> be any flow in <span class="math notranslate nohighlight">\(G\)</span>, recall that the definition of flow value <span class="math notranslate nohighlight">\(\operatorname{val}(f)=f^{\text{out}}(s)\)</span>. For any <span class="math notranslate nohighlight">\(s-t\)</span> cut <span class="math notranslate nohighlight">\(c(A,B)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, the value of the flow <span class="math notranslate nohighlight">\(f\)</span> can be computed as</p>
<div class="math notranslate nohighlight">
\[
  \operatorname{val}(f) = f^{\text{out}}(A) - f^{\text{in}}(A)
  \]</div>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof</em></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\operatorname{val}(f)
&amp;= \sum_{u \in A} \left[ f^{\text{out}}(u) - f^{\text{in}}(u) \right] \\
&amp;= \sum_{u \in A} \left[ \sum_{v} f(u,v) - \sum_{v} f(v,u) \right] \\\\
&amp;= \sum_{u \in A, v \in A}  f(u,v) + \sum_{u \in A, v \in B}  f(u,v) - \sum_{u \in A, v \in A} f(v,u) - \sum_{u \in A, v \in B} f(v,u)  \\\\
&amp;= \sum_{u \in A, v \in B}  f(u,v) - \sum_{u \in A, v \in B} f(v,u)  \\\\
&amp;= f^{\text{out}}(A)- f^{\text{in}}(A)  \\\\
\end{aligned}\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>This corollary is the key for subsequent analysis</p>
</div>
<dl class="simple myst">
<dt>Corollary</dt><dd><p><span class="math notranslate nohighlight">\(\operatorname{val}(f) \le c(A,B)\)</span>, with equality iff <span class="math notranslate nohighlight">\(f^{\text{in}}(A) = 0\)</span> and <span class="math notranslate nohighlight">\(f^{\text{out}}(A) = c(A,B)\)</span>.</p>
</dd>
<dt>Theorem</dt><dd><p>If <span class="math notranslate nohighlight">\(f\)</span> is any <span class="math notranslate nohighlight">\(s-t\)</span> flow and <span class="math notranslate nohighlight">\((A,B)\)</span> is any <span class="math notranslate nohighlight">\(s-t\)</span> cut, and <span class="math notranslate nohighlight">\(\operatorname{val}(f) = c(A,B)\)</span>, then <span class="math notranslate nohighlight">\(f\)</span> is a maximum flow, by Corollary.</p>
</dd>
</dl>
<p>How about existence?</p>
<dl class="simple myst">
<dt>Claim (Optimality)</dt><dd><p>If <span class="math notranslate nohighlight">\(f\)</span> is the flow returned by FF algorithm, then there exists an <span class="math notranslate nohighlight">\(s-t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span> such that <span class="math notranslate nohighlight">\(\operatorname{val}(f) = c(A,B)\)</span>. So <span class="math notranslate nohighlight">\(f\)</span> is optimal by the above theorem.</p>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof</em></p>
<p>Recall that FF algorithm stops if there is no <span class="math notranslate nohighlight">\(s-t\)</span> path. After it stops, consider a cut <span class="math notranslate nohighlight">\((A,B)\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span>, where <span class="math notranslate nohighlight">\(A\)</span> is the set of all vertices <span class="math notranslate nohighlight">\(v \in V\)</span> such that there is an <span class="math notranslate nohighlight">\(s-v\)</span> path in <span class="math notranslate nohighlight">\(G_f\)</span>, and all other vertices (e.g., <span class="math notranslate nohighlight">\(t\)</span>) are in <span class="math notranslate nohighlight">\(B\)</span>. By this definition, there is no edge from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Now, for the cut <span class="math notranslate nohighlight">\((A,B)\)</span> in <span class="math notranslate nohighlight">\(G\)</span>, we want to prove</p>
<div class="math notranslate nohighlight">
\[
\operatorname{val}(f) = c(A,B)
\]</div>
<p>By Corollary, this holds iff <span class="math notranslate nohighlight">\(f^{\text{in}}(A) = 0\)</span> and <span class="math notranslate nohighlight">\(f^{\text{out}}(A) = c(A,B)\)</span>. Equivalently,</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\forall e^+ \in \delta^+(A), f(e^+) = c(e^+)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\forall e^- \in \delta^-(A), f(e^-) = 0 \\\)</span></p></li>
</ol>
<p>These two conditions are indeed satisfied when FF algorithm stops.</p>
<ol class="simple">
<li><p>If there exists <span class="math notranslate nohighlight">\(e^+ = (a,b): f(e^+) &lt; c(e^+)\)</span>, then there is an forward edge <span class="math notranslate nohighlight">\((a,b)\)</span> from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span> with residual capacity <span class="math notranslate nohighlight">\(c_f(a,b) = c(e^+) - f(e^+)&gt;0\)</span>, contradiction to the stoping condition of <span class="math notranslate nohighlight">\(G_f\)</span>.</p></li>
<li><p>If there exists <span class="math notranslate nohighlight">\(e^- = (b,a): f(e^-) &gt; 0\)</span>, then there is an edge <span class="math notranslate nohighlight">\((a,b)\)</span> from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span> with residual capacity <span class="math notranslate nohighlight">\(c_f(a,b) &gt; 0\)</span>, contradiction to the stoping condition of <span class="math notranslate nohighlight">\(G_f\)</span>.</p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
</div>
</div>
<div class="section" id="minimum-cut">
<h2>Minimum Cut<a class="headerlink" href="#minimum-cut" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Problem<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><strong>Input</strong></p>
<ul class="simple">
<li><p>A directed graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>.</p></li>
<li><p>Capacity <span class="math notranslate nohighlight">\(c(e)\)</span>.</p></li>
<li><p>Two special vertices <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
<p><strong>Goal</strong></p>
<p>Find an <span class="math notranslate nohighlight">\(s-t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span> where <span class="math notranslate nohighlight">\(s \in A, t \in B\)</span>, with minimal cut capacity <span class="math notranslate nohighlight">\(c(A,B)\)</span>, which is the sum of capacities of edge from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span>, <span class="math notranslate nohighlight">\(c(A, B) = \sum_{u\in A, v\in B} c(u,v)\)</span>.</p>
<p>In other words, we want to remove some edges to disconnect <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span>, and minimize the total capacities of these removed edges.</p>
<p>The vertex partition’s perspective and edge removal’s perspective are actually equivalent.</p>
</div>
<div class="section" id="id2">
<h3>Analysis<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="simple myst">
<dt>Theorem (Equivalency of maximum flow and minimum cut)</dt><dd><p>In any flow network <span class="math notranslate nohighlight">\(G\)</span>, the value of a maximum <span class="math notranslate nohighlight">\(s-t\)</span> flow is equal to the capacity of a minimum <span class="math notranslate nohighlight">\(s-t\)</span> cut.</p>
</dd>
</dl>
<p>The proof is simply from the Corollary.</p>
<p>Thus, FF algorithm also gives an algorithm for finding a minimum <span class="math notranslate nohighlight">\(s-t\)</span> cut: after the algorithm stops, in the residual graph <span class="math notranslate nohighlight">\(G_f\)</span>, find the set of vertices reachable from <span class="math notranslate nohighlight">\(s\)</span>, then <span class="math notranslate nohighlight">\((A, V\setminus B)\)</span> is a minimum <span class="math notranslate nohighlight">\(s-t\)</span> cut.</p>
</div>
</div>
<div class="section" id="complexity">
<h2>Complexity<a class="headerlink" href="#complexity" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math notranslate nohighlight">\(m\)</span> be the number of edges in the graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Recall that there are at most <span class="math notranslate nohighlight">\(\sum_{v\in \operatorname{succ}(s)} c(s, v)\)</span> iterations. The bound is upper bounded by <span class="math notranslate nohighlight">\(n \times c _{\max}(e)\)</span>.</p>
<p>In each iteration</p>
<ul class="simple">
<li><p>Finding augmenting path <span class="math notranslate nohighlight">\(P\)</span> takes <span class="math notranslate nohighlight">\(O(m)\)</span></p></li>
<li><p>Pushing flow along <span class="math notranslate nohighlight">\(P\)</span> takes <span class="math notranslate nohighlight">\(O(m)\)</span></p></li>
<li><p>Recompute <span class="math notranslate nohighlight">\(G_f\)</span> takes <span class="math notranslate nohighlight">\(O(m)\)</span></p></li>
</ul>
<p>So the total running time is <span class="math notranslate nohighlight">\(O(m\cdot n\cdot c _{\max})\)</span></p>
<div class="note admonition">
<p class="admonition-title"> Is FF algorithm efficient?</p>
<p>There are two inputs.</p>
<ul class="simple">
<li><p>Graph, which is a combinatorial part of size <span class="math notranslate nohighlight">\((n,m)\)</span></p></li>
<li><p>Capacities, which is a numerical part of size <span class="math notranslate nohighlight">\(m\)</span></p></li>
</ul>
<p>Recall different running time</p>
<ul class="simple">
<li><p>strong-polynomial time: <span class="math notranslate nohighlight">\(Poly(\text{input size of the combinatorial part})\)</span>, e.g. <span class="math notranslate nohighlight">\(O(n)\)</span></p></li>
<li><p>weak-polynomial time: <span class="math notranslate nohighlight">\(Poly(\text{input sizes of both parts})\)</span>, e.g. <span class="math notranslate nohighlight">\(O(n \log c_\max)\)</span></p></li>
<li><p>pseudo-polynomial time: <span class="math notranslate nohighlight">\(Poly(\text{the largest integer present in the input})\)</span>, e.g. <span class="math notranslate nohighlight">\(O(c_\max)\)</span></p></li>
</ul>
</div>
</div>
<div class="section" id="improvement-and-extension">
<h2>Improvement and Extension<a class="headerlink" href="#improvement-and-extension" title="Permalink to this headline">¶</a></h2>
<p><span class="math notranslate nohighlight">\(O(mn c_\max)\)</span> is not efficient. There are alternative algorithms to improve this.</p>
<div class="section" id="edmonds-korp-algorithm">
<h3>Edmonds-Korp Algorithm<a class="headerlink" href="#edmonds-korp-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Instead of using an arbitrary augmenting path, we use the <strong>shortest</strong> path <span class="math notranslate nohighlight">\(s-t\)</span> in <span class="math notranslate nohighlight">\(G\)</span> that minimizes number of edges. This work takes <span class="math notranslate nohighlight">\(O(m)\)</span> by BFS or DFS, so each iteration still takes <span class="math notranslate nohighlight">\(O(m)\)</span>. But it reduces the number of iterations from <span class="math notranslate nohighlight">\(O(nc_\max)\)</span> to <span class="math notranslate nohighlight">\(O(nm)\)</span>, this leads to the Edmonds-Korp algorithm with complexity <span class="math notranslate nohighlight">\(O(nm^2)\)</span>.</p>
<p>To show that, we first run that algorithm, record the length of the chosen shortest path in each iteration, and then partition these the execution into phases, where each phase lasts as long as the lengths of augmenting paths chosen remains the same.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\text{iteration} &amp;\quad 1 \quad2 \ \quad 3 \  \quad4 \ \quad 5 \quad6 \quad 7\\
\text{shortest path length} &amp;\quad \underbrace{2 \quad 2}_{\text{phase 1} } \quad \underbrace{3\quad 3}_{\text{phase 2} } \quad \underbrace{5 \quad 5 \quad 5}_{\text{phase 3} }  \\
\end{aligned}\end{split}\]</div>
<dl class="simple myst">
<dt>Claim (Non-decreasing shortest path length)</dt><dd><p>From iteration to iteration, the length of the augmenting path is non-decreasing. Hence, the number of phases is at most <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd>
<dt>Claim (<span class="math notranslate nohighlight">\(O(m)\)</span> iterations in each phase)</dt><dd><p>Every phase covers at most <span class="math notranslate nohighlight">\(O(m)\)</span> iterations.</p>
</dd>
</dl>
<div class="dropdown seealso admonition">
<p class="admonition-title"> <em>Proof</em></p>
<p>To prove them, let <span class="math notranslate nohighlight">\(G_f\)</span> be the residual graph at the <em>start</em> of iteration <span class="math notranslate nohighlight">\(i\)</span>, and <span class="math notranslate nohighlight">\(G_f ^\prime\)</span> be the residual path at the <em>end</em> of iteration <span class="math notranslate nohighlight">\(i\)</span>, and <span class="math notranslate nohighlight">\(P\)</span> be the augmenting path in iteration <span class="math notranslate nohighlight">\(i\)</span>. From the algorithm we observe that</p>
<ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(e \in E(G_f)\)</span> but <span class="math notranslate nohighlight">\(e \notin E(G_f ^\prime)\)</span>, then <span class="math notranslate nohighlight">\(e \in E(P)\)</span></p></li>
<li><p>at least one edge <span class="math notranslate nohighlight">\(e\in P\)</span> has to disappear in <span class="math notranslate nohighlight">\(G ^\prime _f\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(e \notin E(G_f)\)</span> but <span class="math notranslate nohighlight">\(e \in E(G_f ^\prime)\)</span> then its anti-parallel edge <span class="math notranslate nohighlight">\(e ^\prime  \in E(P)\)</span>.</p></li>
</ul>
<p>Now consider using BFS from to find a shortest path <span class="math notranslate nohighlight">\(s-t\)</span> in <span class="math notranslate nohighlight">\(G_f\)</span>. Suppose the path length is <span class="math notranslate nohighlight">\(d\)</span>, then there are <span class="math notranslate nohighlight">\(d+1\)</span> layers. The first layers only contains <span class="math notranslate nohighlight">\(s\)</span>, and the last layer contains <span class="math notranslate nohighlight">\(t\)</span>. In each iteration, we delete some forward-looking edge, and add a backward-looking edge or sideways-looking edge, but <strong>no</strong> shortcut edge. So the shortest path is non-decreasing. Beside, there are at most <span class="math notranslate nohighlight">\(m\)</span> layers to delete in a phase with path length <span class="math notranslate nohighlight">\(d\)</span>, so at most <span class="math notranslate nohighlight">\(O(m)\)</span> iterations in that phase.</p>
<div class="figure align-default" id="max-flow-bfs">
<a class="reference internal image-reference" href="../_images/max-flow-bfs.png"><img alt="" src="../_images/max-flow-bfs.png" style="width: 100%;" /></a>
<p class="caption"><span class="caption-number">Fig. 16 </span><span class="caption-text">BFS in <span class="math notranslate nohighlight">\(G_f\)</span> [Chuzhoy 2021]</span><a class="headerlink" href="#max-flow-bfs" title="Permalink to this image">¶</a></p>
</div>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
</div>
<div class="section" id="approximation">
<h3>Approximation<a class="headerlink" href="#approximation" title="Permalink to this headline">¶</a></h3>
<p><span class="math notranslate nohighlight">\((1+\epsilon)\)</span>-approximation returns a flow of value at least <span class="math notranslate nohighlight">\(\frac{OPT}{1+\epsilon}\)</span>.</p>
</div>
<div class="section" id="other-properties">
<h3>Other Properties<a class="headerlink" href="#other-properties" title="Permalink to this headline">¶</a></h3>
<dl class="simple myst">
<dt>Theorem (Integrality of flow)</dt><dd><p>If all capacities are integers, then the FF algorithm finds a maximum flow where <span class="math notranslate nohighlight">\(f(e)\)</span> is integers for all <span class="math notranslate nohighlight">\(e\)</span>.</p>
</dd>
</dl>
</div>
<div class="section" id="flow-path-perspective">
<h3>Flow-path Perspective<a class="headerlink" href="#flow-path-perspective" title="Permalink to this headline">¶</a></h3>
<p>Recall the flow is define for edges. We can consider a path-based flow <span class="math notranslate nohighlight">\(f^\prime : \mathcal{P}\rightarrow \mathbb{R} _{\ge 0}\)</span>. Let <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> be a set of all <span class="math notranslate nohighlight">\(s-t\)</span> paths. Let <span class="math notranslate nohighlight">\(f ^\prime (P)\)</span> be a flow of a path <span class="math notranslate nohighlight">\(P \in \mathcal{P}\)</span>. It is valid iff</p>
<div class="math notranslate nohighlight">
\[
\forall e:\quad \sum_{P: P \in \mathcal{P} \text{ and } e \in E(P)} f ^\prime (P) \le c(e)
\]</div>
<p>The value of the set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> is <span class="math notranslate nohighlight">\(\sum_{P \in \mathcal{P}}f ^\prime (P)\)</span>.</p>
<dl class="simple myst">
<dt>Theorem (Equivalence)</dt><dd><p>If the original edge-defined flow <span class="math notranslate nohighlight">\(\left\{ f(e) \right\}_{e \in E}\)</span> was feasible, then the path-defined flow <span class="math notranslate nohighlight">\(\left\{ f ^\prime (P) \right\}_{P \in \mathcal{P}}\)</span> is also feasible and has some <strong>integral</strong> value. That is, the two kinds of definition are equivalent.</p>
</dd>
</dl>
</div>
<div class="section" id="undirected-graphs">
<h3>Undirected Graphs<a class="headerlink" href="#undirected-graphs" title="Permalink to this headline">¶</a></h3>
<p>To find max-flow in undirected graph with capacities <span class="math notranslate nohighlight">\(c(e)&gt;0\)</span>, we can make the graph directed.</p>
<ul class="simple">
<li><p>Convert every undirected edge to two anti-parallel directed edges with the same capacity as the undirected edge.</p></li>
<li><p>Run the algorithm for directed graph.</p></li>
<li><p>Finally, run flow cancelation, such that one of the two anti-parallel edges is reduced to 0.</p></li>
</ul>
<p>Meanwhile, we can find a minimum cut on a undirected graph, the capacity/cost of the cut is the sum of the capacities of the edges across <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>.</p>
<div class="math notranslate nohighlight">
\[
\sum _{e \in E(A,B)} c(e)
\]</div>
<p>Likewise, we convert every undirected edge to two anti-parallel directed edges, run FF algorithm to find a <span class="math notranslate nohighlight">\(s-t\)</span> cut. This gives the same value of max <span class="math notranslate nohighlight">\(s-t\)</span> flow.</p>
<p>More efficient algorithm is under research.</p>
</div>
<div class="section" id="edge-disjoint-paths-and-s-t-cut">
<h3>Edge-Disjoint Paths and <span class="math notranslate nohighlight">\(S-T\)</span> Cut<a class="headerlink" href="#edge-disjoint-paths-and-s-t-cut" title="Permalink to this headline">¶</a></h3>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Edge-disjoint path = EDP</p>
</div>
<p>For a directed graph with two disjoint <strong>sets</strong> of vertices <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span>, we want to find a maximum set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> of <span class="math notranslate nohighlight">\(S-T\)</span> paths that are edge-disjoint, i.e. no path in <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> can share any edges.</p>
<p>To solve this,</p>
<ol class="simple">
<li><p>For every edge <span class="math notranslate nohighlight">\(e\in G\)</span>, set capacity <span class="math notranslate nohighlight">\(c(e)=1\)</span>. Add one node <span class="math notranslate nohighlight">\(s\)</span> that connects to every vertex <span class="math notranslate nohighlight">\(u\)</span> in <span class="math notranslate nohighlight">\(S\)</span> with capacity <span class="math notranslate nohighlight">\(\infty\)</span>. Add one node <span class="math notranslate nohighlight">\(t\)</span> that connects to every vertex <span class="math notranslate nohighlight">\(v\)</span> in <span class="math notranslate nohighlight">\(T\)</span> with capacity <span class="math notranslate nohighlight">\(\infty\)</span>.</p></li>
<li><p>Run FF algorithm and obtain a flow <span class="math notranslate nohighlight">\(f\)</span>. Since <span class="math notranslate nohighlight">\(f(e)\)</span> is integer, it is 1.</p></li>
<li><p>Run flow-path decomposition, then each path also carries flow value 1. After we delete the path, we remove all edges along the path since <span class="math notranslate nohighlight">\(c(e)=1\)</span>. Then, the subsequent paths must be disjoint with this one. We will get a collection of EDP from <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(T\)</span>. The number of paths equals to the flow value.</p></li>
</ol>
<p><strong><span class="math notranslate nohighlight">\(S-T\)</span> Cut</strong></p>
<p>Given two sets of vertices <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span> in a directed graph <span class="math notranslate nohighlight">\(G\)</span>, what is the minimum number of edges needed to disconnect <span class="math notranslate nohighlight">\(S\)</span> from <span class="math notranslate nohighlight">\(T\)</span>? Formally, find a minimum-cardinality edge set <span class="math notranslate nohighlight">\(E ^\prime \subset E\)</span> such that in the remaining graph <span class="math notranslate nohighlight">\(G \backslash E ^\prime\)</span>, there is <strong>no</strong> path from a vertex of <span class="math notranslate nohighlight">\(S\)</span> to a vertex of <span class="math notranslate nohighlight">\(T\)</span>.</p>
<dl class="simple myst">
<dt>Menger’s Theorem</dt><dd><p>The maximum number of EDPs connecting <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(T\)</span> is equal to the minimum number of edges needed to disconnect <span class="math notranslate nohighlight">\(S\)</span> from <span class="math notranslate nohighlight">\(T\)</span>.</p>
</dd>
</dl>
<p>The same can be done for undirected graphs.</p>
</div>
<div class="section" id="vertex-capacity-max-flow">
<h3>Vertex-capacity Max Flow<a class="headerlink" href="#vertex-capacity-max-flow" title="Permalink to this headline">¶</a></h3>
<p>In reality, capacities are often defined on vertices, such as computer networks. There are algorithms to solve vertex-capacity max-flow problem.</p>
</div>
</div>
<div class="section" id="applications">
<h2>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">¶</a></h2>
<div class="section" id="image-segmentation">
<h3>Image Segmentation<a class="headerlink" href="#image-segmentation" title="Permalink to this headline">¶</a></h3>
<p>An image can be viewed as a vertex. We want to partition an image into two parts, e.g. foreground and background. For pixel/vertex <span class="math notranslate nohighlight">\(s\)</span>, let <span class="math notranslate nohighlight">\(a_v\)</span> be how likely <span class="math notranslate nohighlight">\(v\)</span> to be in a part, and <span class="math notranslate nohighlight">\(b_v\)</span> be how likely <span class="math notranslate nohighlight">\(v\)</span> to be in the other part.</p>
<p>To solve this, we define strength/similarity for every pair of pixels <span class="math notranslate nohighlight">\(s_{u,v}\)</span>. The ultimate task is to partition the pixels into two sets <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>. The similarity of two pixels from different partition should be small. The objective is</p>
<div class="math notranslate nohighlight">
\[
\max \left\{ \sum_{v \in X} a_v  + \sum_{u \in Y} b_u  - \sum_{v \in X, u\in Y} s_{v,u}  \right\}
\]</div>
<p>which is equivalent to</p>
<div class="math notranslate nohighlight">
\[
\min \left\{ \sum_{v \in X, u\in Y} P_{v,u}  - \sum_{v \in X} a_v  - \sum_{u \in Y} b_u  \right\}
\]</div>
<p>which is equivalent to</p>
<div class="math notranslate nohighlight">
\[
\min \left\{ \sum_{v \in X, u\in Y} s_{v,u}  - \sum_{v \in X} a_v  - \sum_{u \in Y} b_u + \sum_{w \in V} (a_w + b_w) \right\}
\]</div>
<p>which is</p>
<div class="math notranslate nohighlight">
\[
\min \left\{ \sum_{v \in X, u\in Y} s_{v,u}  + \sum_{v \in Y} a_v  + \sum_{u \in X} b_u \right\}
\]</div>
<p>We can solve this with minimum cut on undirected graph. The capacity of an edge is the strength of that edge. For every vertex <span class="math notranslate nohighlight">\(v\)</span>, add edge <span class="math notranslate nohighlight">\((s,v)\)</span> of capacity <span class="math notranslate nohighlight">\(a_v\)</span>, and edge <span class="math notranslate nohighlight">\((v, t)\)</span> of capacity <span class="math notranslate nohighlight">\(b_v\)</span>. Also for add edge <span class="math notranslate nohighlight">\(e(v,u)\)</span> of capacity <span class="math notranslate nohighlight">\(s_{v,u}\)</span> for <span class="math notranslate nohighlight">\(u,v \ne s,t\)</span>. Consider an <span class="math notranslate nohighlight">\(s-t\)</span> cut <span class="math notranslate nohighlight">\((A,B)\)</span>, denote <span class="math notranslate nohighlight">\(X = A \backslash \left\{ s \right\}\)</span> and <span class="math notranslate nohighlight">\(Y = B \backslash \left\{ t \right\}\)</span>.</p>
<dl class="simple myst">
<dt>Claim</dt><dd><p>The capacity of the cut equals the value of the objective function. So the optimization problem in image segmentation can be solved by the minimum cut problem.</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[
c(A,B) = \sum _{e \in E(A,B)} c(e) = f(X,Y)
\]</div>
<p><em><strong>Proof</strong></em></p>
<p>There are 3 kinds of across-set edges in <span class="math notranslate nohighlight">\(E(A, B)\)</span></p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(e=(u,v), u\ne s, v\ne t\)</span>, contribute <span class="math notranslate nohighlight">\(s_e\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(e=(s,x), x\in B \backslash \left\{ t \right\}\)</span> with edge capacity <span class="math notranslate nohighlight">\(a_x\)</span>. Total contribute <span class="math notranslate nohighlight">\(\sum_{x \in Y} a_x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(e=(y,t), y\in A \backslash \left\{ s \right\}\)</span> with edge capacity <span class="math notranslate nohighlight">\(a_x\)</span>. Total contribute <span class="math notranslate nohighlight">\(\sum_{b \in X} b_y\)</span></p></li>
</ol>
<p>Hence</p>
<div class="math notranslate nohighlight">
\[
c(A,B) = \sum_{v \in X, u\in Y} s_{v,u}  + \sum_{v \in Y} a_v  + \sum_{u \in X} b_u
\]</div>
<p>which is exactly the objective function.</p>
<p><span class="math notranslate nohighlight">\(\square\)</span></p>
</div>
</div>
<div class="section" id="exercise">
<h2>Exercise<a class="headerlink" href="#exercise" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be an arbitrary (directed) flow network with integral edge capacities</p>
<ol>
<li><p>T/F: Let <span class="math notranslate nohighlight">\((A,B)\)</span> be a minimum <span class="math notranslate nohighlight">\(s-t\)</span> cut in G. Let <span class="math notranslate nohighlight">\(e=(u,v)\)</span> be an edge of <span class="math notranslate nohighlight">\(G\)</span> with <span class="math notranslate nohighlight">\(u\in A,v\in B\)</span>, and <span class="math notranslate nohighlight">\(c(e) ≥ 1\)</span>. Then <strong>decreasing</strong> the capacity of <span class="math notranslate nohighlight">\(e\)</span> by 1 decreases the maximum flow value by <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>True, since the capacity of all other minimum <span class="math notranslate nohighlight">\(s-t\)</span> cut <strong>without</strong> edge <span class="math notranslate nohighlight">\(e\)</span> are unchanged.</p>
</li>
<li><p>T/F: Let <span class="math notranslate nohighlight">\((A,B)\)</span> be a minimum <span class="math notranslate nohighlight">\(s-t\)</span> cut in G. Let <span class="math notranslate nohighlight">\(e=(u,v)\)</span> be an edge of <span class="math notranslate nohighlight">\(G\)</span> with <span class="math notranslate nohighlight">\(u\in A,v\in B\)</span>, and <span class="math notranslate nohighlight">\(c(e) ≥ 1\)</span>. Then <strong>increasing</strong> the capacity of <span class="math notranslate nohighlight">\(e\)</span> by 1 increases the maximum flow value by <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>False, there may be another minimum <span class="math notranslate nohighlight">\(s-t\)</span> cut <strong>without</strong> edge <span class="math notranslate nohighlight">\(e\)</span>.</p>
</li>
<li><p>T/F: Let <span class="math notranslate nohighlight">\((A,B)\)</span> be a minimum <span class="math notranslate nohighlight">\(s-t\)</span> cut in G. If we <strong>increase</strong> the capacity of <strong>each</strong> edge in <span class="math notranslate nohighlight">\(E(G)\)</span> by <span class="math notranslate nohighlight">\(1\)</span>, then <span class="math notranslate nohighlight">\((A,B)\)</span> remains a minimum <span class="math notranslate nohighlight">\(s-t\)</span> cut in the new flow network.</p>
<p>False. (1) Had G contained edges of different capacities, increased capacity might have resulted in different minimum cut. (2) When all edges have same capacity then minimum cut would remain same.</p>
<p>Example of (1):</p>
<div class="figure align-default" id="max-flow-ex-1">
<a class="reference internal image-reference" href="../_images/max-flow-ex-1.png"><img alt="" src="../_images/max-flow-ex-1.png" style="width: 30%;" /></a>
<p class="caption"><span class="caption-number">Fig. 17 </span><span class="caption-text">New min-cut becomes <span class="math notranslate nohighlight">\(S-A\)</span> with cut capacity <span class="math notranslate nohighlight">\(5\)</span>.</span><a class="headerlink" href="#max-flow-ex-1" title="Permalink to this image">¶</a></p>
</div>
<p>For (2), if all edges have the same capacity <span class="math notranslate nohighlight">\(c\)</span>, then the capacity of any cut is <span class="math notranslate nohighlight">\(nc\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of edges cut. So a min-cut has <span class="math notranslate nohighlight">\(n_\min\)</span>. After <span class="math notranslate nohighlight">\(c\)</span> becomes <span class="math notranslate nohighlight">\(c+1\)</span>, it is still a min-cut since it has <span class="math notranslate nohighlight">\(n_\min\)</span>.</p>
</li>
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> is a valid <span class="math notranslate nohighlight">\(s-t\)</span> flow in graph <span class="math notranslate nohighlight">\(G\)</span> of value <span class="math notranslate nohighlight">\(v_f\)</span>, and <span class="math notranslate nohighlight">\(f ^\prime\)</span> is a valid <span class="math notranslate nohighlight">\(s-t\)</span> flow in the residual graph <span class="math notranslate nohighlight">\(G_f\)</span> of value <span class="math notranslate nohighlight">\(v(f ^\prime)\)</span>, then there is a valid <span class="math notranslate nohighlight">\(s-t\)</span> flow in graph G of value <span class="math notranslate nohighlight">\(v(f) + v(f ^\prime)\)</span>.</p>
<p>True. Moreover, let <span class="math notranslate nohighlight">\(v (f_\max)\)</span> be the value of a max-flow in <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(v (f ^\prime _\max)\)</span> be the value of a max-flow in residual graph <span class="math notranslate nohighlight">\(G_f\)</span>, then we have <span class="math notranslate nohighlight">\(v(f) + v(f ^\prime) \le v (f_\max)\)</span> with equality iff <span class="math notranslate nohighlight">\(v(f ^\prime) = v(f ^\prime _\max)\)</span>.</p>
</li>
<li><p>Increasing the capacity of a single edge <span class="math notranslate nohighlight">\((u,v)\)</span> by <span class="math notranslate nohighlight">\(1\)</span> can result in an increase of at
most 1 in the max flow.</p>
<p>If <span class="math notranslate nohighlight">\((u, v)\)</span> is in every min cut, then increasing the capacity of <span class="math notranslate nohighlight">\((u, v)\)</span> by 1 increases
the min cut value by 1. If (u, v) is not in every min cut, then increasing the capacity of <span class="math notranslate nohighlight">\((u, v)\)</span> by 1 leaves the min cut value unchanged. Either way, the capacity increases by at most 1. The claim follows from the max-flow-min-cut theorem.</p>
</li>
<li><p>Increasing the capacity of a single edge <span class="math notranslate nohighlight">\((u, v)\)</span> by a positive integer <span class="math notranslate nohighlight">\(k\)</span> can result in
an increase of at most <span class="math notranslate nohighlight">\(k\)</span> in the max flow.</p>
<p>Increasing by <span class="math notranslate nohighlight">\(k\)</span> is the same as increasing in <span class="math notranslate nohighlight">\(k\)</span> steps of 1. By part 1, each such step
increases the max flow by at most 1. So the total increase is at most <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>Algorithm:</p>
<ul class="simple">
<li><p>Repeat at most k times:</p>
<ul>
<li><p>Look for an augmenting path in the residual network by BFS/DFS</p></li>
<li><p>If there is one, then add it to the existing flow, else return</p></li>
</ul>
</li>
</ul>
<p>Each pass takes <span class="math notranslate nohighlight">\(O(m)\)</span>, total <span class="math notranslate nohighlight">\(O(km)\)</span>.</p>
</li>
<li><p>Decreasing the capacity of a single edge <span class="math notranslate nohighlight">\((u, v)\)</span> by 1 can result in a decrease of at most 1 in the max flow.</p>
<p>If <span class="math notranslate nohighlight">\((u, v)\)</span> is in some min cut, then decreasing the capacity of <span class="math notranslate nohighlight">\((u, v)\)</span> decreases the
min cut value by 1. If <span class="math notranslate nohighlight">\((u, v)\)</span> is not in every min cut, then decreasing the capacity of
<span class="math notranslate nohighlight">\((u, v)\)</span> by 1 leaves the min cut value unchanged. Either way, the capacity decreases
by at most 1. The claim follows from the max-flow-min-cut theorem.</p>
<p>If <span class="math notranslate nohighlight">\(c(u,v) \ge f(u,v) + 1\)</span>, then the max flow remains the same. If <span class="math notranslate nohighlight">\(c(u,v) = f(u,v)\)</span> (saturated edge), then to satisfy the constraint, we need to remove one unit of flow from <span class="math notranslate nohighlight">\(s\)</span> to <span class="math notranslate nohighlight">\(t\)</span> that goes through edge <span class="math notranslate nohighlight">\((u,v)\)</span>. The algorithm is</p>
<ul class="simple">
<li><p>Find a path <span class="math notranslate nohighlight">\(s-u\)</span> and a path <span class="math notranslate nohighlight">\(v-t\)</span> that contain only edges of positive flow. Remove 1 unit of flow for each edge on path <span class="math notranslate nohighlight">\(s-u\)</span>, and <span class="math notranslate nohighlight">\(v-t\)</span>. This step takes <span class="math notranslate nohighlight">\(O(m)\)</span>.</p></li>
<li><p>Run FF. There is at most one iteration since the flow will increases by at most 1. One iteration takes <span class="math notranslate nohighlight">\(O(m)\)</span>.</p></li>
</ul>
</li>
<li><p>Decreasing the capacity of a single edge <span class="math notranslate nohighlight">\((u, v)\)</span> by a positive integer <span class="math notranslate nohighlight">\(k\)</span> can result
in a decrease of at most <span class="math notranslate nohighlight">\(k\)</span> in the max flow.</p>
<p>Decreasing by <span class="math notranslate nohighlight">\(k\)</span> is the same as decreasing in <span class="math notranslate nohighlight">\(k\)</span> steps of 1. Each such step
decreases the max flow by at most 1. So the total decrease is at most <span class="math notranslate nohighlight">\(k\)</span>.</p>
</li>
<li><p>Vertex-capacity max-flow: capacity constraints are on vertices. Each vertex has capacity constraint <span class="math notranslate nohighlight">\(c(v)\)</span>.</p>
<p>Sol: assign infinite capacity to all edges. Convert each vertex to two vertices connected by an edge, with edge weight <span class="math notranslate nohighlight">\(c(e) = c(v)\)</span>. Equivalent.</p>
</li>
<li><p>Vertex-disjoint path problem: fin maximum number of vertex-disjoint paths (no two paths share vertices) connecting <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>Recall Menger’s Theorem:</p>
<ul class="simple">
<li><p>The maximum number of EDPs connecting <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(T\)</span> is equal to the minimum number of edges needed to disconnect <span class="math notranslate nohighlight">\(S\)</span> from <span class="math notranslate nohighlight">\(T\)</span>.</p></li>
</ul>
<p>The corresponding version in this setting is:</p>
<ul class="simple">
<li><p>The maximum number of <strong>VDPs</strong> connecting <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(T\)</span> is equal to the minimum number of <strong>vertices</strong> needed to disconnect <span class="math notranslate nohighlight">\(S\)</span> from <span class="math notranslate nohighlight">\(T\)</span>.</p></li>
</ul>
</li>
</ol>
<p>http://www.cim.mcgill.ca/~langer/251/E11-networkflow-2.pdf</p>
<p>http://web.stanford.edu/class/archive/cs/cs161/cs161.1176/maxflow_problems.pdf</p>
<p>https://courses.engr.illinois.edu/cs573/fa2012/hw/files/hw_3_pract.pdf</p>
<p>https://www.cs.cornell.edu/courses/cs6820/2016fa/handouts/flows.pdf</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./25-graph-related"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="21-minimum-spanning-tree.html" title="previous page">Minimum Spanning Tree</a>
    <a class='right-next' id="next-link" href="32-matching.html" title="next page">Matching</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Dennis Zheng<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>